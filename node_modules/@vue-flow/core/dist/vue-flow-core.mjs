import { unref as k, ref as oe, watch as ce, customRef as xr, getCurrentScope as ci, onScopeDispose as Bt, getCurrentInstance as tn, onMounted as Ve, nextTick as Ze, readonly as _r, isRef as wr, computed as ee, onBeforeMount as br, markRaw as nt, inject as He, defineComponent as ge, toRef as S, openBlock as ie, createElementBlock as ae, normalizeClass as We, renderSlot as ye, h as le, watchEffect as zn, provide as st, onBeforeUnmount as di, normalizeStyle as Le, createCommentVNode as Ee, createElementVNode as lt, mergeProps as fi, createBlock as Ae, resolveDynamicComponent as hi, Fragment as Ce, createTextVNode as Er, toDisplayString as Bn, Teleport as Sr, normalizeProps as Nr, reactive as Cr, toRefs as Mr, effectScope as $r, renderList as ut, resolveComponent as gi, createVNode as qe, withCtx as Ge, useSlots as kr, onUnmounted as Or } from "vue";
var _o;
const to = typeof window < "u", Ir = (e) => typeof e < "u", Tr = (e) => typeof e == "boolean", ze = (e) => typeof e == "function", Te = (e) => typeof e == "number", Pe = (e) => typeof e == "string", Pr = () => {
};
to && ((_o = window == null ? void 0 : window.navigator) != null && _o.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function se(e) {
  return typeof e == "function" ? e() : k(e);
}
function Dr(e, t) {
  function n(...o) {
    return new Promise((i, r) => {
      Promise.resolve(e(() => t.apply(this, o), { fn: t, thisArg: this, args: o })).then(i).catch(r);
    });
  }
  return n;
}
const vi = (e) => e();
function Ar(e = vi) {
  const t = oe(!0);
  function n() {
    t.value = !1;
  }
  function o() {
    t.value = !0;
  }
  const i = (...r) => {
    t.value && e(...r);
  };
  return { isActive: _r(t), pause: n, resume: o, eventFilter: i };
}
function wo(e, t = !1, n = "Timeout") {
  return new Promise((o, i) => {
    setTimeout(t ? () => i(n) : o, e);
  });
}
function zr(e) {
  return e;
}
function wn(e, t) {
  let n, o, i;
  const r = oe(!0), a = () => {
    r.value = !0, i();
  };
  ce(e, a, { flush: "sync" });
  const s = ze(t) ? t : t.get, l = ze(t) ? void 0 : t.set, u = xr((c, h) => (o = c, i = h, {
    get() {
      return r.value && (n = s(), r.value = !1), o(), n;
    },
    set(g) {
      l == null || l(g);
    }
  }));
  return Object.isExtensible(u) && (u.trigger = a), u;
}
function Mt(e) {
  return ci() ? (Bt(e), !0) : !1;
}
function Br(e, t = !0) {
  tn() ? Ve(e) : t ? e() : Ze(e);
}
function Rn(e, t = !1) {
  function n(h, { flush: g = "sync", deep: w = !1, timeout: f, throwOnTimeout: d } = {}) {
    let _ = null;
    const N = [new Promise((B) => {
      _ = ce(e, (y) => {
        h(y) !== t && (_ == null || _(), B(y));
      }, {
        flush: g,
        deep: w,
        immediate: !0
      });
    })];
    return f != null && N.push(wo(f, d).then(() => se(e)).finally(() => _ == null ? void 0 : _())), Promise.race(N);
  }
  function o(h, g) {
    if (!wr(h))
      return n((y) => y === h, g);
    const { flush: w = "sync", deep: f = !1, timeout: d, throwOnTimeout: _ } = g ?? {};
    let x = null;
    const B = [new Promise((y) => {
      x = ce([e, h], ([$, I]) => {
        t !== ($ === I) && (x == null || x(), y($));
      }, {
        flush: w,
        deep: f,
        immediate: !0
      });
    })];
    return d != null && B.push(wo(d, _).then(() => se(e)).finally(() => (x == null || x(), se(e)))), Promise.race(B);
  }
  function i(h) {
    return n((g) => Boolean(g), h);
  }
  function r(h) {
    return o(null, h);
  }
  function a(h) {
    return o(void 0, h);
  }
  function s(h) {
    return n(Number.isNaN, h);
  }
  function l(h, g) {
    return n((w) => {
      const f = Array.from(w);
      return f.includes(h) || f.includes(se(h));
    }, g);
  }
  function u(h) {
    return c(1, h);
  }
  function c(h = 1, g) {
    let w = -1;
    return n(() => (w += 1, w >= h), g);
  }
  return Array.isArray(se(e)) ? {
    toMatch: n,
    toContains: l,
    changed: u,
    changedTimes: c,
    get not() {
      return Rn(e, !t);
    }
  } : {
    toMatch: n,
    toBe: o,
    toBeTruthy: i,
    toBeNull: r,
    toBeNaN: s,
    toBeUndefined: a,
    changed: u,
    changedTimes: c,
    get not() {
      return Rn(e, !t);
    }
  };
}
function pe(e) {
  return Rn(e);
}
var bo = Object.getOwnPropertySymbols, Rr = Object.prototype.hasOwnProperty, Vr = Object.prototype.propertyIsEnumerable, Hr = (e, t) => {
  var n = {};
  for (var o in e)
    Rr.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && bo)
    for (var o of bo(e))
      t.indexOf(o) < 0 && Vr.call(e, o) && (n[o] = e[o]);
  return n;
};
function Lr(e, t, n = {}) {
  const o = n, {
    eventFilter: i = vi
  } = o, r = Hr(o, [
    "eventFilter"
  ]);
  return ce(e, Dr(i, t), r);
}
var Fr = Object.defineProperty, Gr = Object.defineProperties, Yr = Object.getOwnPropertyDescriptors, Ft = Object.getOwnPropertySymbols, mi = Object.prototype.hasOwnProperty, pi = Object.prototype.propertyIsEnumerable, Eo = (e, t, n) => t in e ? Fr(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Xr = (e, t) => {
  for (var n in t || (t = {}))
    mi.call(t, n) && Eo(e, n, t[n]);
  if (Ft)
    for (var n of Ft(t))
      pi.call(t, n) && Eo(e, n, t[n]);
  return e;
}, Ur = (e, t) => Gr(e, Yr(t)), Zr = (e, t) => {
  var n = {};
  for (var o in e)
    mi.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && Ft)
    for (var o of Ft(e))
      t.indexOf(o) < 0 && pi.call(e, o) && (n[o] = e[o]);
  return n;
};
function Je(e, t, n = {}) {
  const o = n, {
    eventFilter: i
  } = o, r = Zr(o, [
    "eventFilter"
  ]), { eventFilter: a, pause: s, resume: l, isActive: u } = Ar(i);
  return { stop: Lr(e, t, Ur(Xr({}, r), {
    eventFilter: a
  })), pause: s, resume: l, isActive: u };
}
function yi(e) {
  var t;
  const n = se(e);
  return (t = n == null ? void 0 : n.$el) != null ? t : n;
}
const no = to ? window : void 0;
function oo(...e) {
  let t, n, o, i;
  if (Pe(e[0]) || Array.isArray(e[0]) ? ([n, o, i] = e, t = no) : [t, n, o, i] = e, !t)
    return Pr;
  Array.isArray(n) || (n = [n]), Array.isArray(o) || (o = [o]);
  const r = [], a = () => {
    r.forEach((c) => c()), r.length = 0;
  }, s = (c, h, g, w) => (c.addEventListener(h, g, w), () => c.removeEventListener(h, g, w)), l = ce(() => [yi(t), se(i)], ([c, h]) => {
    a(), c && r.push(...n.flatMap((g) => o.map((w) => s(c, g, w, h))));
  }, { immediate: !0, flush: "post" }), u = () => {
    l(), a();
  };
  return Mt(u), u;
}
const Kr = (e) => typeof e == "function" ? e : typeof e == "string" ? (t) => t.key === e : Array.isArray(e) ? (t) => e.includes(t.key) : () => !0;
function So(...e) {
  let t, n, o = {};
  e.length === 3 ? (t = e[0], n = e[1], o = e[2]) : e.length === 2 ? typeof e[1] == "object" ? (t = !0, n = e[0], o = e[1]) : (t = e[0], n = e[1]) : (t = !0, n = e[0]);
  const { target: i = no, eventName: r = "keydown", passive: a = !1 } = o, s = Kr(t);
  return oo(i, r, (u) => {
    s(u) && n(u);
  }, a);
}
function Wr(e, t = !1) {
  const n = oe(), o = () => n.value = Boolean(e());
  return o(), Br(o, t), n;
}
function qr(e) {
  return JSON.parse(JSON.stringify(e));
}
const Vn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Hn = "__vueuse_ssr_handlers__";
Vn[Hn] = Vn[Hn] || {};
Vn[Hn];
var No = Object.getOwnPropertySymbols, jr = Object.prototype.hasOwnProperty, Qr = Object.prototype.propertyIsEnumerable, Jr = (e, t) => {
  var n = {};
  for (var o in e)
    jr.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && No)
    for (var o of No(e))
      t.indexOf(o) < 0 && Qr.call(e, o) && (n[o] = e[o]);
  return n;
};
function ea(e, t, n = {}) {
  const o = n, { window: i = no } = o, r = Jr(o, ["window"]);
  let a;
  const s = Wr(() => i && "ResizeObserver" in i), l = () => {
    a && (a.disconnect(), a = void 0);
  }, u = ce(() => yi(e), (h) => {
    l(), s.value && i && h && (a = new ResizeObserver(t), a.observe(h, r));
  }, { immediate: !0, flush: "post" }), c = () => {
    l(), u();
  };
  return Mt(c), {
    isSupported: s,
    stop: c
  };
}
var Co;
(function(e) {
  e.UP = "UP", e.RIGHT = "RIGHT", e.DOWN = "DOWN", e.LEFT = "LEFT", e.NONE = "NONE";
})(Co || (Co = {}));
var ta = Object.defineProperty, Mo = Object.getOwnPropertySymbols, na = Object.prototype.hasOwnProperty, oa = Object.prototype.propertyIsEnumerable, $o = (e, t, n) => t in e ? ta(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, ia = (e, t) => {
  for (var n in t || (t = {}))
    na.call(t, n) && $o(e, n, t[n]);
  if (Mo)
    for (var n of Mo(t))
      oa.call(t, n) && $o(e, n, t[n]);
  return e;
};
const ra = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
ia({
  linear: zr
}, ra);
function yt(e, t, n, o = {}) {
  var i, r, a;
  const {
    clone: s = !1,
    passive: l = !1,
    eventName: u,
    deep: c = !1,
    defaultValue: h
  } = o, g = tn(), w = n || (g == null ? void 0 : g.emit) || ((i = g == null ? void 0 : g.$emit) == null ? void 0 : i.bind(g)) || ((a = (r = g == null ? void 0 : g.proxy) == null ? void 0 : r.$emit) == null ? void 0 : a.bind(g == null ? void 0 : g.proxy));
  let f = u;
  t || (t = "modelValue"), f = u || f || `update:${t.toString()}`;
  const d = (x) => s ? ze(s) ? s(x) : qr(x) : x, _ = () => Ir(e[t]) ? d(e[t]) : h;
  if (l) {
    const x = _(), N = oe(x);
    return ce(() => e[t], (B) => N.value = d(B)), ce(N, (B) => {
      (B !== e[t] || c) && w(f, B);
    }, { deep: c }), N;
  } else
    return ee({
      get() {
        return _();
      },
      set(x) {
        w(f, x);
      }
    });
}
function X(e = () => {
}) {
  const t = oe(/* @__PURE__ */ new Set());
  e && t.value.add(e);
  const n = (r) => {
    t.value.delete(r);
  };
  return {
    on: (r) => {
      t.value.has(e) && t.value.delete(e), t.value.add(r);
      const a = () => n(r);
      return Mt(a), {
        off: a
      };
    },
    off: n,
    trigger: (r) => Promise.all(Array.from(t.value).map((a) => a(r))),
    fns: t
  };
}
const aa = ["production", "prod"];
function wt(e, ...t) {
  aa.includes(process.env.NODE_ENV || "") || console.warn(`[Vue Flow]: ${e}`, ...t);
}
function sa() {
  return {
    edgesChange: X(),
    nodesChange: X(),
    nodeDoubleClick: X(),
    nodeClick: X(),
    nodeMouseEnter: X(),
    nodeMouseMove: X(),
    nodeMouseLeave: X(),
    nodeContextMenu: X(),
    nodeDragStart: X(),
    nodeDrag: X(),
    nodeDragStop: X(),
    nodesInitialized: X(),
    miniMapNodeClick: X(),
    miniMapNodeDoubleClick: X(),
    miniMapNodeMouseEnter: X(),
    miniMapNodeMouseMove: X(),
    miniMapNodeMouseLeave: X(),
    connect: X(),
    connectStart: X(),
    connectEnd: X(),
    clickConnectStart: X(),
    clickConnectEnd: X(),
    paneReady: X(),
    move: X(),
    moveStart: X(),
    moveEnd: X(),
    selectionDragStart: X(),
    selectionDrag: X(),
    selectionDragStop: X(),
    selectionContextMenu: X(),
    selectionStart: X(),
    selectionEnd: X(),
    viewportChangeStart: X(),
    viewportChange: X(),
    viewportChangeEnd: X(),
    paneScroll: X(),
    paneClick: X(),
    paneContextMenu: X(),
    paneMouseEnter: X(),
    paneMouseMove: X(),
    paneMouseLeave: X(),
    edgeContextMenu: X(),
    edgeMouseEnter: X(),
    edgeMouseMove: X(),
    edgeMouseLeave: X(),
    edgeDoubleClick: X(),
    edgeClick: X(),
    edgeUpdateStart: X(),
    edgeUpdate: X(),
    edgeUpdateEnd: X(),
    updateNodeInternals: X(),
    error: X((e) => wt(e.message))
  };
}
function la(e, t) {
  br(() => {
    for (const [n, o] of Object.entries(t.value)) {
      const i = (r) => {
        e(n, r);
      };
      o.on(i), Mt(() => {
        o.off(i);
      });
    }
  });
}
var he = /* @__PURE__ */ ((e) => (e.MISSING_VIEWPORT_DIMENSIONS = "MISSING_VIEWPORT_DIMENSIONS", e.NODE_NOT_FOUND = "NODE_NOT_FOUND", e.NODE_MISSING_PARENT = "NODE_MISSING_PARENT", e.NODE_TYPE_MISSING = "NODE_TYPE_MISSING", e.NODE_EXTENT_INVALID = "NODE_EXTENT_INVALID", e.EDGE_INVALID = "EDGE_INVALID", e.EDGE_NOT_FOUND = "EDGE_NOT_FOUND", e.EDGE_SOURCE_MISSING = "EDGE_SOURCE_MISSING", e.EDGE_TARGET_MISSING = "EDGE_TARGET_MISSING", e.EDGE_TYPE_MISSING = "EDGE_TYPE_MISSING", e.EDGE_SOURCE_TARGET_SAME = "EDGE_SOURCE_TARGET_SAME", e.EDGE_SOURCE_TARGET_MISSING = "EDGE_SOURCE_TARGET_MISSING", e.EDGE_ORPHANED = "EDGE_ORPHANED", e))(he || {});
const bn = {
  MISSING_VIEWPORT_DIMENSIONS: () => "The Vue Flow parent container needs a width and a height to render the graph",
  NODE_NOT_FOUND: (e) => `Node not found
Node: ${e}`,
  NODE_MISSING_PARENT: (e, t) => `Node is missing a parent
Node: ${e}
Parent: ${t}`,
  NODE_TYPE_MISSING: (e) => `Node type is missing
Type: ${e}`,
  NODE_EXTENT_INVALID: (e) => `Only child nodes can use a parent extent
Node: ${e}`,
  EDGE_INVALID: (e) => `An edge needs a source and a target
Edge: ${e}`,
  EDGE_SOURCE_MISSING: (e, t) => `Edge source is missing
Edge: ${e} 
Source: ${t}`,
  EDGE_TARGET_MISSING: (e, t) => `Edge target is missing
Edge: ${e} 
Target: ${t}`,
  EDGE_TYPE_MISSING: (e) => `Edge type is missing
Type: ${e}`,
  EDGE_SOURCE_TARGET_SAME: (e, t, n) => `Edge source and target are the same
Edge: ${e} 
Source: ${t} 
Target: ${n}`,
  EDGE_SOURCE_TARGET_MISSING: (e, t, n) => `Edge source or target is missing
Edge: ${e} 
Source: ${t} 
Target: ${n}`,
  EDGE_ORPHANED: (e) => `Edge was orphaned (suddenly missing source or target) and has been removed
Edge: ${e}`,
  EDGE_NOT_FOUND: (e) => `Edge not found
Edge: ${e}`
};
class ve extends Error {
  constructor(t, ...n) {
    var o;
    super((o = bn[t]) == null ? void 0 : o.call(bn, ...n)), this.code = t;
  }
}
const io = () => typeof window < "u" ? window : { chrome: !1 };
function ko(e) {
  return {
    ...e.computedPosition || { x: 0, y: 0 },
    width: e.dimensions.width || 0,
    height: e.dimensions.height || 0
  };
}
function Ln(e, t) {
  const n = Math.max(0, Math.min(e.x + e.width, t.x + t.width) - Math.max(e.x, t.x)), o = Math.max(0, Math.min(e.y + e.height, t.y + t.height) - Math.max(e.y, t.y));
  return Math.ceil(n * o);
}
function nn(e) {
  return {
    width: e.offsetWidth,
    height: e.offsetHeight
  };
}
function ct(e, t = 0, n = 1) {
  return Math.min(Math.max(e, t), n);
}
function ro(e, t) {
  return {
    x: ct(e.x, t[0][0], t[1][0]),
    y: ct(e.y, t[0][1], t[1][1])
  };
}
function Oo(e) {
  const t = e.getRootNode(), n = io();
  return "elementFromPoint" in t ? t : n.document;
}
function $e(e) {
  return e && "id" in e && "source" in e && "target" in e;
}
function ua(e) {
  return $e(e) && "sourceNode" in e && "targetNode" in e;
}
function xt(e) {
  return e && "id" in e && !$e(e);
}
function et(e) {
  return xt(e) && "computedPosition" in e;
}
function ca(e) {
  return !!e.width && !!e.height && !!e.x && !!e.y;
}
function da(e, t = {}) {
  let n = t;
  return et(e) || (n = {
    type: e.type ?? t.type ?? "default",
    dimensions: nt({
      width: 0,
      height: 0
    }),
    handleBounds: {
      source: [],
      target: []
    },
    computedPosition: nt({
      z: 0,
      ...e.position
    }),
    draggable: void 0,
    selectable: void 0,
    connectable: void 0,
    focusable: void 0,
    selected: !1,
    dragging: !1,
    resizing: !1,
    initialized: !1,
    ...t,
    data: ue(e.data) ? e.data : {},
    events: nt(ue(e.events) ? e.events : {})
  }), Object.assign({}, n, e, { id: e.id.toString() });
}
function ao(e, t = {}) {
  const n = ue(e.events) ? e.events : t.events && ue(t.events) ? t.events : {}, o = ue(e.data) ? e.data : t.data && ue(t.data) ? t.data : {};
  return t = ua(e) ? t : {
    ...t,
    sourceHandle: (e.sourceHandle ? e.sourceHandle.toString() : void 0) || t.sourceHandle,
    targetHandle: (e.targetHandle ? e.targetHandle.toString() : void 0) || t.targetHandle,
    type: e.type ?? t.type ?? "default",
    source: e.source.toString() || t.source,
    target: e.target.toString() || t.target,
    updatable: e.updatable ?? t.updatable,
    selectable: e.selectable ?? t.selectable,
    focusable: e.focusable ?? t.focusable,
    data: o,
    events: nt(n),
    label: (e.label && !Pe(e.label) ? nt(e.label) : e.label) || t.label,
    interactionWidth: e.interactionWidth || t.interactionWidth
  }, Object.assign({}, t, e, { id: e.id.toString() });
}
function xi(e, t, n) {
  if (!xt(e))
    return [];
  const o = n === "source" ? "target" : "source", i = t.filter((r) => $e(r) && r[o] === e.id).map((r) => $e(r) && r[n]);
  return t.filter((r) => i.includes(r.id));
}
function Od(e, t) {
  return xi(e, t, "target");
}
function Id(e, t) {
  return xi(e, t, "source");
}
function on({ source: e, sourceHandle: t, target: n, targetHandle: o }) {
  return `vueflow__edge-${e}${t ?? ""}-${n}${o ?? ""}`;
}
function _i(e, t) {
  return t.some(
    (n) => $e(n) && n.source === e.source && n.target === e.target && (n.sourceHandle === e.sourceHandle || !n.sourceHandle && !e.sourceHandle) && (n.targetHandle === e.targetHandle || !n.targetHandle && !e.targetHandle)
  );
}
function Td(e, t, n) {
  if (!e.source || !e.target)
    return wt("Can't create edge. An edge needs a source and a target."), t;
  let o;
  return $e(e) ? o = { ...e } : o = {
    ...e,
    id: on(e)
  }, o = ao(o, n), _i(o, t) || t.push(o), t;
}
function Pd(e, t, n) {
  if (!t.source || !t.target)
    return wt("Can't create new edge. An edge needs a source and a target."), n;
  const o = n.find((r) => $e(r) && r.id === e.id);
  if (!o)
    return wt(`The old edge with id=${e.id} does not exist.`), n;
  const i = {
    ...e,
    id: on(t),
    source: t.source,
    target: t.target,
    sourceHandle: t.sourceHandle,
    targetHandle: t.targetHandle
  };
  return n.splice(n.indexOf(o), 1, i), n.filter((r) => r.id !== e.id);
}
function fa({ x: e, y: t }, { x: n, y: o, zoom: i }) {
  return {
    x: e * i + n,
    y: t * i + o
  };
}
function so({ x: e, y: t }, { x: n, y: o, zoom: i }, r, [a, s]) {
  const l = {
    x: (e - n) / i,
    y: (t - o) / i
  };
  return r ? {
    x: a * Math.round(l.x / a),
    y: s * Math.round(l.y / s)
  } : l;
}
function wi(e, t) {
  return {
    x: Math.min(e.x, t.x),
    y: Math.min(e.y, t.y),
    x2: Math.max(e.x2, t.x2),
    y2: Math.max(e.y2, t.y2)
  };
}
function Gt({ x: e, y: t, width: n, height: o }) {
  return {
    x: e,
    y: t,
    x2: e + n,
    y2: t + o
  };
}
function bi({ x: e, y: t, x2: n, y2: o }) {
  return {
    x: e,
    y: t,
    width: n - e,
    height: o - t
  };
}
function Dd(e, t) {
  return bi(wi(Gt(e), Gt(t)));
}
function lo(e) {
  const t = e.reduce(
    (n, { computedPosition: o = { x: 0, y: 0 }, dimensions: i = { width: 0, height: 0 } } = {}) => wi(
      n,
      Gt({
        ...o,
        ...i
      })
    ),
    { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 }
  );
  return bi(t);
}
function Ei(e, t, { x: n, y: o, zoom: i } = { x: 0, y: 0, zoom: 1 }, r = !1, a = !1) {
  const s = {
    x: (t.x - n) / i,
    y: (t.y - o) / i,
    width: t.width / i,
    height: t.height / i
  };
  return e.filter((l) => {
    const { computedPosition: u = { x: 0, y: 0 }, dimensions: c = { width: 0, height: 0 }, selectable: h } = l;
    if (a && !h)
      return !1;
    const g = { ...u, width: c.width || 0, height: c.height || 0 }, w = Ln(s, g), f = typeof c.width > "u" || typeof c.height > "u" || c.width === 0 || c.height === 0, d = r && w > 0, _ = c.width * c.height;
    return f || d || w >= _;
  });
}
function rn(e, t) {
  const n = e.map((o) => Pe(o) ? o : o.id);
  return t.filter((o) => n.includes(o.source) || n.includes(o.target));
}
function Yt(e, t, n, o, i, r = 0.1, a = { x: 0, y: 0 }) {
  const s = t / (e.width * (1 + r)), l = n / (e.height * (1 + r)), u = Math.min(s, l), c = ct(u, o, i), h = e.x + e.width / 2, g = e.y + e.height / 2, w = t / 2 - h * c + (a.x ?? 0), f = n / 2 - g * c + (a.y ?? 0);
  return { x: w, y: f, zoom: c };
}
function ha(e, t) {
  return {
    x: t.x + e.x,
    y: t.y + e.y,
    z: (e.z > t.z ? e.z : t.z) + 1
  };
}
function Si(e, t) {
  if (!e.parentNode)
    return !1;
  const n = t(e.parentNode);
  return n ? n.selected ? !0 : Si(n, t) : !1;
}
function Xe(e, t) {
  return typeof e > "u" ? "" : typeof e == "string" ? e : `${t ? `${t}__` : ""}${Object.keys(e).sort().map((o) => `${o}=${e[o]}`).join("&")}`;
}
function ue(e) {
  return typeof k(e) < "u";
}
function ga(e, t, n) {
  if (!e.source || !e.target)
    return n(new ve(he.EDGE_INVALID, e.id)), !1;
  let o;
  return $e(e) ? o = e : o = {
    ...e,
    id: on(e)
  }, o = ao(o), _i(o, t) ? !1 : o;
}
function va(e, t, n, o, i, r) {
  if (!t.source || !t.target)
    return r(new ve(he.EDGE_INVALID, e.id)), !1;
  const a = o(e.id);
  if (!a)
    return r(new ve(he.EDGE_NOT_FOUND, e.id)), !1;
  const { id: s, ...l } = e, u = {
    ...l,
    id: i ? on(t) : s,
    source: t.source,
    target: t.target,
    sourceHandle: t.sourceHandle,
    targetHandle: t.targetHandle
  };
  return n.splice(n.indexOf(a), 1, u), u;
}
function Io(e, t, n, o) {
  const i = {}, r = e.map((s) => {
    const l = da(s, {
      ...n(s.id),
      parentNode: s.parentNode
    });
    return s.parentNode && (i[s.parentNode] = !0), l;
  }), a = [...r, ...t];
  return r.forEach((s) => {
    const l = a.find((u) => u.id === s.parentNode);
    s.parentNode && !l && o(new ve(he.NODE_MISSING_PARENT, s.id, s.parentNode)), (s.parentNode || i[s.id]) && (i[s.id] && (s.isParent = !0), l && (l.isParent = !0));
  }), r;
}
var Q = /* @__PURE__ */ ((e) => (e.Left = "left", e.Top = "top", e.Right = "right", e.Bottom = "bottom", e))(Q || {}), uo = /* @__PURE__ */ ((e) => (e.Partial = "partial", e.Full = "full", e))(uo || {}), Ye = /* @__PURE__ */ ((e) => (e.Bezier = "default", e.SimpleBezier = "simple-bezier", e.Straight = "straight", e.Step = "step", e.SmoothStep = "smoothstep", e))(Ye || {}), je = /* @__PURE__ */ ((e) => (e.Strict = "strict", e.Loose = "loose", e))(je || {}), Fn = /* @__PURE__ */ ((e) => (e.Arrow = "arrow", e.ArrowClosed = "arrowclosed", e))(Fn || {}), Xt = /* @__PURE__ */ ((e) => (e.Free = "free", e.Vertical = "vertical", e.Horizontal = "horizontal", e))(Xt || {}), ma = /* @__PURE__ */ ((e) => (e.TopLeft = "top-left", e.TopCenter = "top-center", e.TopRight = "top-right", e.BottomLeft = "bottom-left", e.BottomCenter = "bottom-center", e.BottomRight = "bottom-right", e))(ma || {});
const To = Symbol("vueFlow"), Ni = Symbol("nodeId"), Ci = Symbol("nodeRef"), Mi = Symbol("edgeId"), $i = Symbol("edgeRef"), an = Symbol("slots");
function pa(e) {
  const t = e ?? He(Ni, ""), n = He(Ci, null), { findNode: o, edges: i, emits: r } = de(), a = o(t);
  return a || r.error(new ve(he.NODE_NOT_FOUND, t)), {
    id: t,
    nodeEl: n,
    node: a,
    parentNode: ee(() => o(a.parentNode)),
    connectedEdges: ee(() => rn([a], i.value))
  };
}
function co(e) {
  return "clientX" in e;
}
function ot(e, t) {
  var r, a;
  const n = co(e), o = n ? e.clientX : (r = e.touches) == null ? void 0 : r[0].clientX, i = n ? e.clientY : (a = e.touches) == null ? void 0 : a[0].clientY;
  return {
    x: o - ((t == null ? void 0 : t.left) ?? 0),
    y: i - ((t == null ? void 0 : t.top) ?? 0)
  };
}
function Ut(e, t, n) {
  const o = ((n == null ? void 0 : n.x) ?? 0) + t.x, i = ((n == null ? void 0 : n.y) ?? 0) + t.y, r = (n == null ? void 0 : n.width) ?? t.width, a = (n == null ? void 0 : n.height) ?? t.height;
  switch (e) {
    case Q.Top:
      return {
        x: o + r / 2,
        y: i
      };
    case Q.Right:
      return {
        x: o + r,
        y: i + a / 2
      };
    case Q.Bottom:
      return {
        x: o + r / 2,
        y: i + a
      };
    case Q.Left:
      return {
        x: o,
        y: i + a / 2
      };
  }
}
function Po(e = [], t) {
  return e.length ? !t || e.length === 1 ? e[0] : t && e.find((n) => n.id === t) || null : null;
}
function ya(e, t, n, o, i, r) {
  const a = Ut(
    n,
    {
      ...e.dimensions,
      ...e.computedPosition
    },
    t
  ), s = Ut(
    r,
    {
      ...o.dimensions,
      ...o.computedPosition
    },
    i
  );
  return {
    sourceX: a.x,
    sourceY: a.y,
    targetX: s.x,
    targetY: s.y
  };
}
function xa({
  sourcePos: e,
  targetPos: t,
  sourceWidth: n,
  sourceHeight: o,
  targetWidth: i,
  targetHeight: r,
  width: a,
  height: s,
  viewport: l
}) {
  const u = {
    x: Math.min(e.x, t.x),
    y: Math.min(e.y, t.y),
    x2: Math.max(e.x + n, t.x + i),
    y2: Math.max(e.y + o, t.y + r)
  };
  u.x === u.x2 && (u.x2 += 1), u.y === u.y2 && (u.y2 += 1);
  const c = Gt({
    x: (0 - l.x) / l.zoom,
    y: (0 - l.y) / l.zoom,
    width: a / l.zoom,
    height: s / l.zoom
  }), h = Math.max(0, Math.min(c.x2, u.x2) - Math.max(c.x, u.x)), g = Math.max(0, Math.min(c.y2, u.y2) - Math.max(c.y, u.y));
  return Math.ceil(h * g) > 0;
}
function _a(e, t, n = !1) {
  let o = -1;
  const i = e.reduce((r, a) => {
    const s = Te(a.zIndex);
    let l = s ? a.zIndex : 0;
    const u = t(a.source), c = t(a.target);
    return !u || !c || (n && (l = s ? a.zIndex : Math.max(u.computedPosition.z || 0, c.computedPosition.z || 0)), r[l] ? r[l].push(a) : r[l] = [a], o = l > o ? l : o), r;
  }, {});
  return Object.entries(Object.keys(i).length ? i : { 0: [] }).map(([r, a]) => {
    const s = +r;
    return {
      edges: a,
      level: s,
      isMaxLevel: s === o
    };
  });
}
function En(e) {
  e == null || e.classList.remove("valid", "connecting", "vue-flow__handle-valid", "vue-flow__handle-connecting");
}
function Do(e, t, n, o) {
  return (t[n] || []).reduce((i, r) => (`${e.id}-${r.id}-${n}` !== o && i.push({
    id: r.id || null,
    type: n,
    nodeId: e.id,
    ...Ut(
      r.position,
      {
        ...e.dimensions,
        ...e.computedPosition
      },
      r
    )
  }), i), []);
}
function wa(e, t, n) {
  let o = null, i = 1 / 0;
  return n.forEach((r) => {
    const a = Math.sqrt((r.x - e.x) ** 2 + (r.y - e.y) ** 2);
    a <= t && a < i && (i = a, o = r);
  }), o;
}
function Ao(e, t, n, o, i, r, a, s, l, u) {
  const c = r === "target", h = s.querySelector(`.vue-flow__handle[data-id="${t == null ? void 0 : t.nodeId}-${t == null ? void 0 : t.id}-${t == null ? void 0 : t.type}"]`), { x: g, y: w } = ot(e), f = s.elementFromPoint(g, w), d = f != null && f.classList.contains("vue-flow__handle") ? f : h, _ = {
    handleDomNode: d,
    isValid: !1,
    connection: { source: "", target: "", sourceHandle: null, targetHandle: null },
    endHandle: null
  };
  if (d) {
    const x = ki(void 0, d), N = d.getAttribute("data-nodeid"), B = d.getAttribute("data-handleid"), y = d.classList.contains("connectable"), $ = d.classList.contains("connectableend"), I = {
      source: c ? N : o,
      sourceHandle: c ? B : i,
      target: c ? o : N,
      targetHandle: c ? i : B
    };
    _.connection = I, y && $ && (n === je.Strict ? c && x === "source" || !c && x === "target" : N !== o || B !== i) && (_.endHandle = {
      nodeId: N,
      handleId: B,
      type: x
    }, _.isValid = a(I, {
      edges: l,
      sourceNode: u(I.source),
      targetNode: u(I.target)
    }));
  }
  return _;
}
function ba({ nodes: e, nodeId: t, handleId: n, handleType: o }) {
  return e.reduce((i, r) => {
    const { handleBounds: a } = r;
    let s = [], l = [];
    return a && (s = Do(r, a, "source", `${t}-${n}-${o}`), l = Do(r, a, "target", `${t}-${n}-${o}`)), i.push(...s, ...l), i;
  }, []);
}
function ki(e, t) {
  return e || (t != null && t.classList.contains("target") ? "target" : t != null && t.classList.contains("source") ? "source" : null);
}
function Ea(e, t) {
  let n = null;
  return t ? n = "valid" : e && !t && (n = "invalid"), n;
}
function zo(e, t, n) {
  return e < t ? ct(Math.abs(e - t), 1, 50) / 50 : e > n ? -ct(Math.abs(e - n), 1, 50) / 50 : 0;
}
function Oi(e, t) {
  const n = zo(e.x, 35, t.width - 35) * 20, o = zo(e.y, 35, t.height - 35) * 20;
  return [n, o];
}
function Ot() {
  return !0;
}
function Ii({
  handleId: e,
  nodeId: t,
  type: n,
  isValidConnection: o,
  edgeUpdaterType: i,
  onEdgeUpdate: r,
  onEdgeUpdateEnd: a
}) {
  const s = ee(() => se(n) === "target"), {
    vueFlowRef: l,
    connectionMode: u,
    connectionRadius: c,
    connectOnClick: h,
    connectionClickStartHandle: g,
    nodesConnectable: w,
    autoPanOnConnect: f,
    findNode: d,
    panBy: _,
    getNodes: x,
    startConnection: N,
    updateConnection: B,
    endConnection: y,
    emits: $,
    viewport: I,
    edges: m,
    isValidConnection: G
  } = de();
  let D = null, M = !1, H = null;
  function j(p) {
    var L;
    const R = co(p), E = Oo(p.target);
    if (R && p.button === 0 || !R) {
      let U = function(z) {
        F = ot(z, v), A = wa(
          so(F, I.value, !1, [1, 1]),
          c.value,
          V
        ), T || (C(), T = !0);
        const ne = Ao(
          z,
          A,
          u.value,
          se(t),
          se(e),
          s.value ? "target" : "source",
          K,
          E,
          m.value,
          d
        );
        if (D = ne.connection, M = ne.isValid, H = ne.handleDomNode, B(
          A && M ? fa(
            {
              x: A.x,
              y: A.y
            },
            I.value
          ) : F,
          ne.endHandle,
          Ea(!!A, M)
        ), !A && !M && !H)
          return En(b);
        D && D.source !== D.target && H && (En(b), b = H, H.classList.add("connecting", "vue-flow__handle-connecting"), H.classList.toggle("valid", M), H.classList.toggle("vue-flow__handle-valid", M));
      }, W = function(z) {
        (A || H) && D && M && (r ? r(z, D) : $.connect(D)), $.connectEnd(z), i && (a == null || a(z)), En(b), cancelAnimationFrame(J), y(z), T = !1, M = !1, D = null, H = null, E.removeEventListener("mousemove", U), E.removeEventListener("mouseup", W), E.removeEventListener("touchmove", U), E.removeEventListener("touchend", W);
      };
      const P = d(se(t));
      let K = o || G.value || Ot;
      !K && P && (K = (s ? P.isValidSourcePos : P.isValidTargetPos) || Ot);
      let A, J = 0;
      const { x: Z, y: q } = ot(p), O = E == null ? void 0 : E.elementFromPoint(Z, q), Y = ki(se(i), O), v = (L = l.value) == null ? void 0 : L.getBoundingClientRect();
      if (!v || !Y)
        return;
      let b, F = ot(p, v), T = !1;
      const V = ba({
        nodes: x.value,
        nodeId: se(t),
        handleId: se(e),
        handleType: Y
      }), C = () => {
        if (!f)
          return;
        const [z, ne] = Oi(F, v);
        _({ x: z, y: ne }), J = requestAnimationFrame(C);
      };
      N(
        {
          nodeId: se(t),
          handleId: se(e),
          type: Y
        },
        {
          x: Z - v.left,
          y: q - v.top
        },
        p
      ), $.connectStart({ event: p, nodeId: se(t), handleId: se(e), handleType: Y }), E.addEventListener("mousemove", U), E.addEventListener("mouseup", W), E.addEventListener("touchmove", U), E.addEventListener("touchend", W);
    }
  }
  function te(p) {
    if (h.value)
      if (!g.value)
        $.clickConnectStart({ event: p, nodeId: se(t), handleId: se(e) }), N(
          { nodeId: se(t), type: se(n), handleId: se(e) },
          void 0,
          p,
          !0
        );
      else {
        let R = o || G.value || Ot;
        const E = d(se(t));
        if (!R && E && (R = (s ? E.isValidSourcePos : E.isValidTargetPos) || Ot), E && (typeof E.connectable > "u" ? w.value : E.connectable) === !1)
          return;
        const L = Oo(p.target), { connection: U, isValid: W } = Ao(
          p,
          {
            nodeId: se(t),
            id: se(e),
            type: se(n)
          },
          u.value,
          g.value.nodeId,
          g.value.handleId || null,
          g.value.type,
          R,
          L,
          m.value,
          d
        ), P = U.source === U.target;
        W && !P && $.connect(U), $.clickConnectEnd(p), y(p, !0);
      }
  }
  return {
    handlePointerDown: j,
    handleClick: te
  };
}
function Sa(e, t) {
  const n = {};
  for (const o in e)
    t.includes(o) || Object.defineProperty(n, o, {
      enumerable: !0,
      get: () => e[o]
    });
  return n;
}
const Na = ["data-id", "data-handleid", "data-nodeid", "data-handlepos"], Ca = {
  name: "Handle",
  compatConfig: { MODE: 3 }
}, Zt = /* @__PURE__ */ ge({
  ...Ca,
  props: {
    id: null,
    type: null,
    position: { default: Q.Top },
    isValidConnection: { type: Function },
    connectable: { type: [Boolean, String, Function], default: void 0 },
    connectableStart: { type: Boolean, default: !0 },
    connectableEnd: { type: Boolean, default: !0 }
  },
  setup(e) {
    const t = Sa(e, ["position", "connectable", "connectableStart", "connectableEnd", "id", "isValidConnection"]), n = S(t, "type", "source"), {
      connectionStartHandle: o,
      connectionClickStartHandle: i,
      connectionEndHandle: r,
      vueFlowRef: a,
      nodesConnectable: s,
      noDragClassName: l,
      noPanClassName: u
    } = de(), { id: c, node: h, nodeEl: g, connectedEdges: w } = pa(), f = oe(), d = ee(() => e.id ?? `${c}__handle-${e.position}`), _ = ee(() => typeof e.connectableStart < "u" ? e.connectableStart : !0), x = ee(() => typeof e.connectableEnd < "u" ? e.connectableEnd : !0), { handlePointerDown: N, handleClick: B } = Ii({
      nodeId: c,
      handleId: d,
      isValidConnection: e.isValidConnection,
      type: n
    }), y = ee(() => Pe(e.connectable) && e.connectable === "single" ? !w.value.some((D) => {
      const M = D[`${n.value}Handle`];
      return D[n.value] !== c ? !1 : M ? M === d.value : !0;
    }) : ze(e.connectable) ? e.connectable(h, w.value) : ue(e.connectable) ? e.connectable : s.value), $ = ee(
      () => {
        var D, M, H, j, te, p;
        return ((D = o.value) == null ? void 0 : D.nodeId) === c && ((M = o.value) == null ? void 0 : M.handleId) === d.value && ((H = o.value) == null ? void 0 : H.type) === n.value || ((j = r.value) == null ? void 0 : j.nodeId) === c && ((te = r.value) == null ? void 0 : te.handleId) === d.value && ((p = r.value) == null ? void 0 : p.type) === n.value;
      }
    ), I = ee(
      () => {
        var D, M, H;
        return ((D = i.value) == null ? void 0 : D.nodeId) === c && ((M = i.value) == null ? void 0 : M.handleId) === d.value && ((H = i.value) == null ? void 0 : H.type) === n.value;
      }
    );
    pe(() => h.initialized).toBe(!0, { flush: "post" }).then(() => {
      var E;
      const D = (E = h.handleBounds[n.value]) == null ? void 0 : E.find((L) => L.id === d.value);
      if (!a.value || D)
        return;
      const M = a.value.querySelector(".vue-flow__transformationpane");
      if (!g || !f.value || !M || !d.value)
        return;
      const H = g.value.getBoundingClientRect(), j = f.value.getBoundingClientRect(), te = window.getComputedStyle(M), { m22: p } = new window.DOMMatrixReadOnly(te.transform), R = {
        id: d.value,
        position: e.position,
        x: (j.left - H.left) / p,
        y: (j.top - H.top) / p,
        ...nn(f.value)
      };
      h.handleBounds[n.value] = [...h.handleBounds[n.value] ?? [], R];
    });
    function m(D) {
      const M = co(D);
      y.value && _.value && (M && D.button === 0 || !M) && N(D);
    }
    function G(D) {
      !c || !i.value && !_.value || y.value && B(D);
    }
    return (D, M) => (ie(), ae("div", {
      ref_key: "handle",
      ref: f,
      "data-id": `${k(c)}-${k(d)}-${k(n)}`,
      "data-handleid": k(d),
      "data-nodeid": k(c),
      "data-handlepos": e.position,
      class: We(["vue-flow__handle", [
        `vue-flow__handle-${e.position}`,
        `vue-flow__handle-${k(d)}`,
        k(l),
        k(u),
        k(n),
        {
          connectable: k(y),
          connecting: k(I),
          connectablestart: k(_),
          connectableend: k(x),
          connectionindicator: k(y) && (k(_) && !k($) || k(x) && k($))
        }
      ]]),
      onMousedown: m,
      onTouchstartPassive: m,
      onClick: G
    }, [
      ye(D.$slots, "default", { id: e.id })
    ], 42, Na));
  }
}), sn = function({
  sourcePosition: e = Q.Bottom,
  targetPosition: t = Q.Top,
  label: n,
  connectable: o = !0,
  isValidTargetPos: i,
  isValidSourcePos: r
}) {
  return [
    le(Zt, { type: "target", position: t, connectable: o, isValidConnection: i }),
    typeof n != "string" && n ? le(n) : le("div", { innerHTML: n }),
    le(Zt, { type: "source", position: e, connectable: o, isValidConnection: r })
  ];
};
sn.props = ["sourcePosition", "targetPosition", "label", "isValidTargetPos", "isValidSourcePos", "connectable"];
sn.inheritAttrs = !1;
sn.compatConfig = { MODE: 3 };
const Ma = sn, ln = function({
  sourcePosition: e = Q.Bottom,
  label: t,
  connectable: n = !0,
  isValidSourcePos: o
}) {
  return [
    typeof t != "string" && t ? le(t) : le("div", { innerHTML: t }),
    le(Zt, { type: "source", position: e, connectable: n, isValidConnection: o })
  ];
};
ln.props = ["sourcePosition", "label", "isValidSourcePos", "connectable"];
ln.inheritAttrs = !1;
ln.compatConfig = { MODE: 3 };
const $a = ln, un = function({
  targetPosition: e = Q.Top,
  label: t,
  connectable: n = !0,
  isValidTargetPos: o
}) {
  return [
    le(Zt, { type: "target", position: e, connectable: n, isValidConnection: o }),
    typeof t != "string" && t ? le(t) : le("div", { innerHTML: t })
  ];
};
un.props = ["targetPosition", "label", "isValidTargetPos", "connectable"];
un.inheritAttrs = !1;
un.compatConfig = { MODE: 3 };
const ka = un;
function Bo(e, t, n) {
  let o = e;
  do {
    if (o && o.matches(t))
      return !0;
    if (o === n)
      return !1;
    o = o.parentElement;
  } while (o);
  return !1;
}
function Oa(e, t, n, o, i) {
  return e.filter(
    (r) => (r.selected || r.id === i) && (!r.parentNode || !Si(r, o)) && (r.draggable || t && typeof r.draggable > "u")
  ).map(
    (r) => {
      var a, s;
      return nt({
        id: r.id,
        position: r.position || { x: 0, y: 0 },
        distance: {
          x: n.x - ((a = r.computedPosition) == null ? void 0 : a.x) || 0,
          y: n.y - ((s = r.computedPosition) == null ? void 0 : s.y) || 0
        },
        from: r.computedPosition,
        extent: r.extent,
        parentNode: r.parentNode,
        dimensions: r.dimensions
      });
    }
  );
}
function Sn({
  id: e,
  dragItems: t,
  findNode: n
}) {
  const o = t.map((i) => n(i.id));
  return [e ? o.find((i) => i.id === e) : o[0], o];
}
function Ti(e) {
  if (Array.isArray(e))
    switch (e.length) {
      case 1:
        return [e[0], e[0], e[0], e[0]];
      case 2:
        return [e[0], e[1], e[0], e[1]];
      case 3:
        return [e[0], e[1], e[2], e[1]];
      case 4:
        return e;
      default:
        return [0, 0, 0, 0];
    }
  return [e, e, e, e];
}
function Ia(e, t, n) {
  const [o, i, r, a] = typeof e != "string" ? Ti(e.padding) : [0, 0, 0, 0];
  return n && Te(n.computedPosition.x) && Te(n.computedPosition.y) && Te(n.dimensions.width) && Te(n.dimensions.height) ? [
    [n.computedPosition.x + a, n.computedPosition.y + o],
    [
      n.computedPosition.x + (n.dimensions.width - t.dimensions.width) - i,
      n.computedPosition.y + (n.dimensions.height - t.dimensions.height) - r
    ]
  ] : !1;
}
function Ta(e, t, n, o) {
  let i = e.extent || n;
  if (i === "parent" || !Array.isArray(i) && (i == null ? void 0 : i.range) === "parent")
    if (e.parentNode && o && e.dimensions.width && e.dimensions.height) {
      const r = Ia(i, e, o);
      r && (i = r);
    } else
      t(new ve(he.NODE_EXTENT_INVALID, e.id)), i = n;
  else if (Array.isArray(i)) {
    const r = (o == null ? void 0 : o.computedPosition.x) || 0, a = (o == null ? void 0 : o.computedPosition.y) || 0;
    i = [
      [i[0][0] + r, i[0][1] + a],
      [i[1][0] + r, i[1][1] + a]
    ];
  } else if (i != null && i.range && Array.isArray(i.range)) {
    const [r, a, s, l] = Ti(i.padding), u = (o == null ? void 0 : o.computedPosition.x) || 0, c = (o == null ? void 0 : o.computedPosition.y) || 0;
    i = [
      [i.range[0][0] + u + l, i.range[0][1] + c + r],
      [i.range[1][0] + u - a, i.range[1][1] + c - s]
    ];
  }
  return i;
}
function fo(e, t, n, o, i) {
  const r = Ta(e, n, o, i), a = ro(t, r);
  return {
    position: {
      x: a.x - ((i == null ? void 0 : i.computedPosition.x) || 0),
      y: a.y - ((i == null ? void 0 : i.computedPosition.y) || 0)
    },
    computedPosition: a
  };
}
function Pi() {
  const { getSelectedNodes: e, nodeExtent: t, updateNodePositions: n, findNode: o, snapGrid: i, snapToGrid: r, nodesDraggable: a, emits: s } = de();
  return (l, u = !1) => {
    const c = r.value ? i.value[0] : 5, h = r.value ? i.value[1] : 5, g = u ? 4 : 1, w = l.x * c * g, f = l.y * h * g, d = e.value.filter((_) => _.draggable || a && typeof _.draggable > "u").map((_) => {
      const x = { x: _.computedPosition.x + w, y: _.computedPosition.y + f }, { computedPosition: N } = fo(
        _,
        x,
        s.error,
        t.value,
        _.parentNode ? o(_.parentNode) : void 0
      );
      return {
        id: _.id,
        position: N,
        from: _.position,
        distance: { x: l.x, y: l.y },
        dimensions: _.dimensions
      };
    });
    n(d, !0, !1);
  };
}
function Pa() {
  return {
    doubleClick: X(),
    click: X(),
    mouseEnter: X(),
    mouseMove: X(),
    mouseLeave: X(),
    contextMenu: X(),
    dragStart: X(),
    drag: X(),
    dragStop: X()
  };
}
function Da(e, t) {
  const n = Pa();
  return n.doubleClick.on((o) => {
    var i, r;
    t.nodeDoubleClick(o), (r = (i = e.events) == null ? void 0 : i.doubleClick) == null || r.call(i, o);
  }), n.click.on((o) => {
    var i, r;
    t.nodeClick(o), (r = (i = e.events) == null ? void 0 : i.click) == null || r.call(i, o);
  }), n.mouseEnter.on((o) => {
    var i, r;
    t.nodeMouseEnter(o), (r = (i = e.events) == null ? void 0 : i.mouseEnter) == null || r.call(i, o);
  }), n.mouseMove.on((o) => {
    var i, r;
    t.nodeMouseMove(o), (r = (i = e.events) == null ? void 0 : i.mouseMove) == null || r.call(i, o);
  }), n.mouseLeave.on((o) => {
    var i, r;
    t.nodeMouseLeave(o), (r = (i = e.events) == null ? void 0 : i.mouseLeave) == null || r.call(i, o);
  }), n.contextMenu.on((o) => {
    var i, r;
    t.nodeContextMenu(o), (r = (i = e.events) == null ? void 0 : i.contextMenu) == null || r.call(i, o);
  }), n.dragStart.on((o) => {
    var i, r;
    t.nodeDragStart(o), (r = (i = e.events) == null ? void 0 : i.dragStart) == null || r.call(i, o);
  }), n.drag.on((o) => {
    var i, r;
    t.nodeDrag(o), (r = (i = e.events) == null ? void 0 : i.drag) == null || r.call(i, o);
  }), n.dragStop.on((o) => {
    var i, r;
    t.nodeDragStop(o), (r = (i = e.events) == null ? void 0 : i.dragStop) == null || r.call(i, o);
  }), Object.entries(n).reduce(
    (o, [i, r]) => (o.emit[i] = r.trigger, o.on[i] = r.on, o),
    { emit: {}, on: {} }
  );
}
function Aa() {
  const { viewport: e, snapGrid: t, snapToGrid: n } = de();
  return ({ sourceEvent: o }) => {
    const i = o.touches ? o.touches[0].clientX : o.clientX, r = o.touches ? o.touches[0].clientY : o.clientY, a = {
      x: (i - e.value.x) / e.value.zoom,
      y: (r - e.value.y) / e.value.zoom
    };
    return {
      xSnapped: n.value ? t.value[0] * Math.round(a.x / t.value[0]) : a.x,
      ySnapped: n.value ? t.value[1] * Math.round(a.y / t.value[1]) : a.y,
      ...a
    };
  };
}
function Ro(e, t, n) {
  const o = t.querySelectorAll(`.vue-flow__handle${e}`);
  if (!o || !o.length)
    return;
  const i = Array.from(o), r = t.getBoundingClientRect();
  return i.map((a) => {
    const s = a.getBoundingClientRect();
    return {
      id: a.getAttribute("data-handleid"),
      position: a.getAttribute("data-handlepos"),
      x: (s.left - r.left) / n,
      y: (s.top - r.top) / n,
      ...nn(a)
    };
  });
}
function Gn(e, t, n, o, i, r = !1, a) {
  i.value = !1, e.selected ? (r || e.selected && t) && (o([e]), Ze(a.blur)) : n([e]);
}
var za = { value: () => {
} };
function cn() {
  for (var e = 0, t = arguments.length, n = {}, o; e < t; ++e) {
    if (!(o = arguments[e] + "") || o in n || /[\s.]/.test(o))
      throw new Error("illegal type: " + o);
    n[o] = [];
  }
  return new Rt(n);
}
function Rt(e) {
  this._ = e;
}
function Ba(e, t) {
  return e.trim().split(/^|\s+/).map(function(n) {
    var o = "", i = n.indexOf(".");
    if (i >= 0 && (o = n.slice(i + 1), n = n.slice(0, i)), n && !t.hasOwnProperty(n))
      throw new Error("unknown type: " + n);
    return { type: n, name: o };
  });
}
Rt.prototype = cn.prototype = {
  constructor: Rt,
  on: function(e, t) {
    var n = this._, o = Ba(e + "", n), i, r = -1, a = o.length;
    if (arguments.length < 2) {
      for (; ++r < a; )
        if ((i = (e = o[r]).type) && (i = Ra(n[i], e.name)))
          return i;
      return;
    }
    if (t != null && typeof t != "function")
      throw new Error("invalid callback: " + t);
    for (; ++r < a; )
      if (i = (e = o[r]).type)
        n[i] = Vo(n[i], e.name, t);
      else if (t == null)
        for (i in n)
          n[i] = Vo(n[i], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var n in t)
      e[n] = t[n].slice();
    return new Rt(e);
  },
  call: function(e, t) {
    if ((i = arguments.length - 2) > 0)
      for (var n = new Array(i), o = 0, i, r; o < i; ++o)
        n[o] = arguments[o + 2];
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (r = this._[e], o = 0, i = r.length; o < i; ++o)
      r[o].value.apply(t, n);
  },
  apply: function(e, t, n) {
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (var o = this._[e], i = 0, r = o.length; i < r; ++i)
      o[i].value.apply(t, n);
  }
};
function Ra(e, t) {
  for (var n = 0, o = e.length, i; n < o; ++n)
    if ((i = e[n]).name === t)
      return i.value;
}
function Vo(e, t, n) {
  for (var o = 0, i = e.length; o < i; ++o)
    if (e[o].name === t) {
      e[o] = za, e = e.slice(0, o).concat(e.slice(o + 1));
      break;
    }
  return n != null && e.push({ name: t, value: n }), e;
}
var Yn = "http://www.w3.org/1999/xhtml";
const Ho = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: Yn,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function dn(e) {
  var t = e += "", n = t.indexOf(":");
  return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), Ho.hasOwnProperty(t) ? { space: Ho[t], local: e } : e;
}
function Va(e) {
  return function() {
    var t = this.ownerDocument, n = this.namespaceURI;
    return n === Yn && t.documentElement.namespaceURI === Yn ? t.createElement(e) : t.createElementNS(n, e);
  };
}
function Ha(e) {
  return function() {
    return this.ownerDocument.createElementNS(e.space, e.local);
  };
}
function Di(e) {
  var t = dn(e);
  return (t.local ? Ha : Va)(t);
}
function La() {
}
function ho(e) {
  return e == null ? La : function() {
    return this.querySelector(e);
  };
}
function Fa(e) {
  typeof e != "function" && (e = ho(e));
  for (var t = this._groups, n = t.length, o = new Array(n), i = 0; i < n; ++i)
    for (var r = t[i], a = r.length, s = o[i] = new Array(a), l, u, c = 0; c < a; ++c)
      (l = r[c]) && (u = e.call(l, l.__data__, c, r)) && ("__data__" in l && (u.__data__ = l.__data__), s[c] = u);
  return new xe(o, this._parents);
}
function Ga(e) {
  return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
}
function Ya() {
  return [];
}
function Ai(e) {
  return e == null ? Ya : function() {
    return this.querySelectorAll(e);
  };
}
function Xa(e) {
  return function() {
    return Ga(e.apply(this, arguments));
  };
}
function Ua(e) {
  typeof e == "function" ? e = Xa(e) : e = Ai(e);
  for (var t = this._groups, n = t.length, o = [], i = [], r = 0; r < n; ++r)
    for (var a = t[r], s = a.length, l, u = 0; u < s; ++u)
      (l = a[u]) && (o.push(e.call(l, l.__data__, u, a)), i.push(l));
  return new xe(o, i);
}
function zi(e) {
  return function() {
    return this.matches(e);
  };
}
function Bi(e) {
  return function(t) {
    return t.matches(e);
  };
}
var Za = Array.prototype.find;
function Ka(e) {
  return function() {
    return Za.call(this.children, e);
  };
}
function Wa() {
  return this.firstElementChild;
}
function qa(e) {
  return this.select(e == null ? Wa : Ka(typeof e == "function" ? e : Bi(e)));
}
var ja = Array.prototype.filter;
function Qa() {
  return Array.from(this.children);
}
function Ja(e) {
  return function() {
    return ja.call(this.children, e);
  };
}
function es(e) {
  return this.selectAll(e == null ? Qa : Ja(typeof e == "function" ? e : Bi(e)));
}
function ts(e) {
  typeof e != "function" && (e = zi(e));
  for (var t = this._groups, n = t.length, o = new Array(n), i = 0; i < n; ++i)
    for (var r = t[i], a = r.length, s = o[i] = [], l, u = 0; u < a; ++u)
      (l = r[u]) && e.call(l, l.__data__, u, r) && s.push(l);
  return new xe(o, this._parents);
}
function Ri(e) {
  return new Array(e.length);
}
function ns() {
  return new xe(this._enter || this._groups.map(Ri), this._parents);
}
function Kt(e, t) {
  this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
}
Kt.prototype = {
  constructor: Kt,
  appendChild: function(e) {
    return this._parent.insertBefore(e, this._next);
  },
  insertBefore: function(e, t) {
    return this._parent.insertBefore(e, t);
  },
  querySelector: function(e) {
    return this._parent.querySelector(e);
  },
  querySelectorAll: function(e) {
    return this._parent.querySelectorAll(e);
  }
};
function os(e) {
  return function() {
    return e;
  };
}
function is(e, t, n, o, i, r) {
  for (var a = 0, s, l = t.length, u = r.length; a < u; ++a)
    (s = t[a]) ? (s.__data__ = r[a], o[a] = s) : n[a] = new Kt(e, r[a]);
  for (; a < l; ++a)
    (s = t[a]) && (i[a] = s);
}
function rs(e, t, n, o, i, r, a) {
  var s, l, u = /* @__PURE__ */ new Map(), c = t.length, h = r.length, g = new Array(c), w;
  for (s = 0; s < c; ++s)
    (l = t[s]) && (g[s] = w = a.call(l, l.__data__, s, t) + "", u.has(w) ? i[s] = l : u.set(w, l));
  for (s = 0; s < h; ++s)
    w = a.call(e, r[s], s, r) + "", (l = u.get(w)) ? (o[s] = l, l.__data__ = r[s], u.delete(w)) : n[s] = new Kt(e, r[s]);
  for (s = 0; s < c; ++s)
    (l = t[s]) && u.get(g[s]) === l && (i[s] = l);
}
function as(e) {
  return e.__data__;
}
function ss(e, t) {
  if (!arguments.length)
    return Array.from(this, as);
  var n = t ? rs : is, o = this._parents, i = this._groups;
  typeof e != "function" && (e = os(e));
  for (var r = i.length, a = new Array(r), s = new Array(r), l = new Array(r), u = 0; u < r; ++u) {
    var c = o[u], h = i[u], g = h.length, w = ls(e.call(c, c && c.__data__, u, o)), f = w.length, d = s[u] = new Array(f), _ = a[u] = new Array(f), x = l[u] = new Array(g);
    n(c, h, d, _, x, w, t);
    for (var N = 0, B = 0, y, $; N < f; ++N)
      if (y = d[N]) {
        for (N >= B && (B = N + 1); !($ = _[B]) && ++B < f; )
          ;
        y._next = $ || null;
      }
  }
  return a = new xe(a, o), a._enter = s, a._exit = l, a;
}
function ls(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function us() {
  return new xe(this._exit || this._groups.map(Ri), this._parents);
}
function cs(e, t, n) {
  var o = this.enter(), i = this, r = this.exit();
  return typeof e == "function" ? (o = e(o), o && (o = o.selection())) : o = o.append(e + ""), t != null && (i = t(i), i && (i = i.selection())), n == null ? r.remove() : n(r), o && i ? o.merge(i).order() : i;
}
function ds(e) {
  for (var t = e.selection ? e.selection() : e, n = this._groups, o = t._groups, i = n.length, r = o.length, a = Math.min(i, r), s = new Array(i), l = 0; l < a; ++l)
    for (var u = n[l], c = o[l], h = u.length, g = s[l] = new Array(h), w, f = 0; f < h; ++f)
      (w = u[f] || c[f]) && (g[f] = w);
  for (; l < i; ++l)
    s[l] = n[l];
  return new xe(s, this._parents);
}
function fs() {
  for (var e = this._groups, t = -1, n = e.length; ++t < n; )
    for (var o = e[t], i = o.length - 1, r = o[i], a; --i >= 0; )
      (a = o[i]) && (r && a.compareDocumentPosition(r) ^ 4 && r.parentNode.insertBefore(a, r), r = a);
  return this;
}
function hs(e) {
  e || (e = gs);
  function t(h, g) {
    return h && g ? e(h.__data__, g.__data__) : !h - !g;
  }
  for (var n = this._groups, o = n.length, i = new Array(o), r = 0; r < o; ++r) {
    for (var a = n[r], s = a.length, l = i[r] = new Array(s), u, c = 0; c < s; ++c)
      (u = a[c]) && (l[c] = u);
    l.sort(t);
  }
  return new xe(i, this._parents).order();
}
function gs(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function vs() {
  var e = arguments[0];
  return arguments[0] = this, e.apply(null, arguments), this;
}
function ms() {
  return Array.from(this);
}
function ps() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var o = e[t], i = 0, r = o.length; i < r; ++i) {
      var a = o[i];
      if (a)
        return a;
    }
  return null;
}
function ys() {
  let e = 0;
  for (const t of this)
    ++e;
  return e;
}
function xs() {
  return !this.node();
}
function _s(e) {
  for (var t = this._groups, n = 0, o = t.length; n < o; ++n)
    for (var i = t[n], r = 0, a = i.length, s; r < a; ++r)
      (s = i[r]) && e.call(s, s.__data__, r, i);
  return this;
}
function ws(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function bs(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function Es(e, t) {
  return function() {
    this.setAttribute(e, t);
  };
}
function Ss(e, t) {
  return function() {
    this.setAttributeNS(e.space, e.local, t);
  };
}
function Ns(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttribute(e) : this.setAttribute(e, n);
  };
}
function Cs(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n);
  };
}
function Ms(e, t) {
  var n = dn(e);
  if (arguments.length < 2) {
    var o = this.node();
    return n.local ? o.getAttributeNS(n.space, n.local) : o.getAttribute(n);
  }
  return this.each((t == null ? n.local ? bs : ws : typeof t == "function" ? n.local ? Cs : Ns : n.local ? Ss : Es)(n, t));
}
function Vi(e) {
  return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
}
function $s(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function ks(e, t, n) {
  return function() {
    this.style.setProperty(e, t, n);
  };
}
function Os(e, t, n) {
  return function() {
    var o = t.apply(this, arguments);
    o == null ? this.style.removeProperty(e) : this.style.setProperty(e, o, n);
  };
}
function Is(e, t, n) {
  return arguments.length > 1 ? this.each((t == null ? $s : typeof t == "function" ? Os : ks)(e, t, n ?? "")) : dt(this.node(), e);
}
function dt(e, t) {
  return e.style.getPropertyValue(t) || Vi(e).getComputedStyle(e, null).getPropertyValue(t);
}
function Ts(e) {
  return function() {
    delete this[e];
  };
}
function Ps(e, t) {
  return function() {
    this[e] = t;
  };
}
function Ds(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? delete this[e] : this[e] = n;
  };
}
function As(e, t) {
  return arguments.length > 1 ? this.each((t == null ? Ts : typeof t == "function" ? Ds : Ps)(e, t)) : this.node()[e];
}
function Hi(e) {
  return e.trim().split(/^|\s+/);
}
function go(e) {
  return e.classList || new Li(e);
}
function Li(e) {
  this._node = e, this._names = Hi(e.getAttribute("class") || "");
}
Li.prototype = {
  add: function(e) {
    var t = this._names.indexOf(e);
    t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(e) {
    var t = this._names.indexOf(e);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(e) {
    return this._names.indexOf(e) >= 0;
  }
};
function Fi(e, t) {
  for (var n = go(e), o = -1, i = t.length; ++o < i; )
    n.add(t[o]);
}
function Gi(e, t) {
  for (var n = go(e), o = -1, i = t.length; ++o < i; )
    n.remove(t[o]);
}
function zs(e) {
  return function() {
    Fi(this, e);
  };
}
function Bs(e) {
  return function() {
    Gi(this, e);
  };
}
function Rs(e, t) {
  return function() {
    (t.apply(this, arguments) ? Fi : Gi)(this, e);
  };
}
function Vs(e, t) {
  var n = Hi(e + "");
  if (arguments.length < 2) {
    for (var o = go(this.node()), i = -1, r = n.length; ++i < r; )
      if (!o.contains(n[i]))
        return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? Rs : t ? zs : Bs)(n, t));
}
function Hs() {
  this.textContent = "";
}
function Ls(e) {
  return function() {
    this.textContent = e;
  };
}
function Fs(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function Gs(e) {
  return arguments.length ? this.each(e == null ? Hs : (typeof e == "function" ? Fs : Ls)(e)) : this.node().textContent;
}
function Ys() {
  this.innerHTML = "";
}
function Xs(e) {
  return function() {
    this.innerHTML = e;
  };
}
function Us(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function Zs(e) {
  return arguments.length ? this.each(e == null ? Ys : (typeof e == "function" ? Us : Xs)(e)) : this.node().innerHTML;
}
function Ks() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function Ws() {
  return this.each(Ks);
}
function qs() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function js() {
  return this.each(qs);
}
function Qs(e) {
  var t = typeof e == "function" ? e : Di(e);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function Js() {
  return null;
}
function el(e, t) {
  var n = typeof e == "function" ? e : Di(e), o = t == null ? Js : typeof t == "function" ? t : ho(t);
  return this.select(function() {
    return this.insertBefore(n.apply(this, arguments), o.apply(this, arguments) || null);
  });
}
function tl() {
  var e = this.parentNode;
  e && e.removeChild(this);
}
function nl() {
  return this.each(tl);
}
function ol() {
  var e = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function il() {
  var e = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function rl(e) {
  return this.select(e ? il : ol);
}
function al(e) {
  return arguments.length ? this.property("__data__", e) : this.node().__data__;
}
function sl(e) {
  return function(t) {
    e.call(this, t, this.__data__);
  };
}
function ll(e) {
  return e.trim().split(/^|\s+/).map(function(t) {
    var n = "", o = t.indexOf(".");
    return o >= 0 && (n = t.slice(o + 1), t = t.slice(0, o)), { type: t, name: n };
  });
}
function ul(e) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var n = 0, o = -1, i = t.length, r; n < i; ++n)
        r = t[n], (!e.type || r.type === e.type) && r.name === e.name ? this.removeEventListener(r.type, r.listener, r.options) : t[++o] = r;
      ++o ? t.length = o : delete this.__on;
    }
  };
}
function cl(e, t, n) {
  return function() {
    var o = this.__on, i, r = sl(t);
    if (o) {
      for (var a = 0, s = o.length; a < s; ++a)
        if ((i = o[a]).type === e.type && i.name === e.name) {
          this.removeEventListener(i.type, i.listener, i.options), this.addEventListener(i.type, i.listener = r, i.options = n), i.value = t;
          return;
        }
    }
    this.addEventListener(e.type, r, n), i = { type: e.type, name: e.name, value: t, listener: r, options: n }, o ? o.push(i) : this.__on = [i];
  };
}
function dl(e, t, n) {
  var o = ll(e + ""), i, r = o.length, a;
  if (arguments.length < 2) {
    var s = this.node().__on;
    if (s) {
      for (var l = 0, u = s.length, c; l < u; ++l)
        for (i = 0, c = s[l]; i < r; ++i)
          if ((a = o[i]).type === c.type && a.name === c.name)
            return c.value;
    }
    return;
  }
  for (s = t ? cl : ul, i = 0; i < r; ++i)
    this.each(s(o[i], t, n));
  return this;
}
function Yi(e, t, n) {
  var o = Vi(e), i = o.CustomEvent;
  typeof i == "function" ? i = new i(t, n) : (i = o.document.createEvent("Event"), n ? (i.initEvent(t, n.bubbles, n.cancelable), i.detail = n.detail) : i.initEvent(t, !1, !1)), e.dispatchEvent(i);
}
function fl(e, t) {
  return function() {
    return Yi(this, e, t);
  };
}
function hl(e, t) {
  return function() {
    return Yi(this, e, t.apply(this, arguments));
  };
}
function gl(e, t) {
  return this.each((typeof t == "function" ? hl : fl)(e, t));
}
function* vl() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var o = e[t], i = 0, r = o.length, a; i < r; ++i)
      (a = o[i]) && (yield a);
}
var Xi = [null];
function xe(e, t) {
  this._groups = e, this._parents = t;
}
function $t() {
  return new xe([[document.documentElement]], Xi);
}
function ml() {
  return this;
}
xe.prototype = $t.prototype = {
  constructor: xe,
  select: Fa,
  selectAll: Ua,
  selectChild: qa,
  selectChildren: es,
  filter: ts,
  data: ss,
  enter: ns,
  exit: us,
  join: cs,
  merge: ds,
  selection: ml,
  order: fs,
  sort: hs,
  call: vs,
  nodes: ms,
  node: ps,
  size: ys,
  empty: xs,
  each: _s,
  attr: Ms,
  style: Is,
  property: As,
  classed: Vs,
  text: Gs,
  html: Zs,
  raise: Ws,
  lower: js,
  append: Qs,
  insert: el,
  remove: nl,
  clone: rl,
  datum: al,
  on: dl,
  dispatch: gl,
  [Symbol.iterator]: vl
};
function we(e) {
  return typeof e == "string" ? new xe([[document.querySelector(e)]], [document.documentElement]) : new xe([[e]], Xi);
}
function pl(e) {
  let t;
  for (; t = e.sourceEvent; )
    e = t;
  return e;
}
function Ne(e, t) {
  if (e = pl(e), t === void 0 && (t = e.currentTarget), t) {
    var n = t.ownerSVGElement || t;
    if (n.createSVGPoint) {
      var o = n.createSVGPoint();
      return o.x = e.clientX, o.y = e.clientY, o = o.matrixTransform(t.getScreenCTM().inverse()), [o.x, o.y];
    }
    if (t.getBoundingClientRect) {
      var i = t.getBoundingClientRect();
      return [e.clientX - i.left - t.clientLeft, e.clientY - i.top - t.clientTop];
    }
  }
  return [e.pageX, e.pageY];
}
const yl = { passive: !1 }, bt = { capture: !0, passive: !1 };
function Nn(e) {
  e.stopImmediatePropagation();
}
function it(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function Ui(e) {
  var t = e.document.documentElement, n = we(e).on("dragstart.drag", it, bt);
  "onselectstart" in t ? n.on("selectstart.drag", it, bt) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
}
function Zi(e, t) {
  var n = e.document.documentElement, o = we(e).on("dragstart.drag", null);
  t && (o.on("click.drag", it, bt), setTimeout(function() {
    o.on("click.drag", null);
  }, 0)), "onselectstart" in n ? o.on("selectstart.drag", null) : (n.style.MozUserSelect = n.__noselect, delete n.__noselect);
}
const It = (e) => () => e;
function Xn(e, {
  sourceEvent: t,
  subject: n,
  target: o,
  identifier: i,
  active: r,
  x: a,
  y: s,
  dx: l,
  dy: u,
  dispatch: c
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    subject: { value: n, enumerable: !0, configurable: !0 },
    target: { value: o, enumerable: !0, configurable: !0 },
    identifier: { value: i, enumerable: !0, configurable: !0 },
    active: { value: r, enumerable: !0, configurable: !0 },
    x: { value: a, enumerable: !0, configurable: !0 },
    y: { value: s, enumerable: !0, configurable: !0 },
    dx: { value: l, enumerable: !0, configurable: !0 },
    dy: { value: u, enumerable: !0, configurable: !0 },
    _: { value: c }
  });
}
Xn.prototype.on = function() {
  var e = this._.on.apply(this._, arguments);
  return e === this._ ? this : e;
};
function xl(e) {
  return !e.ctrlKey && !e.button;
}
function _l() {
  return this.parentNode;
}
function wl(e, t) {
  return t ?? { x: e.x, y: e.y };
}
function bl() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function El() {
  var e = xl, t = _l, n = wl, o = bl, i = {}, r = cn("start", "drag", "end"), a = 0, s, l, u, c, h = 0;
  function g(y) {
    y.on("mousedown.drag", w).filter(o).on("touchstart.drag", _).on("touchmove.drag", x, yl).on("touchend.drag touchcancel.drag", N).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function w(y, $) {
    if (!(c || !e.call(this, y, $))) {
      var I = B(this, t.call(this, y, $), y, $, "mouse");
      I && (we(y.view).on("mousemove.drag", f, bt).on("mouseup.drag", d, bt), Ui(y.view), Nn(y), u = !1, s = y.clientX, l = y.clientY, I("start", y));
    }
  }
  function f(y) {
    if (it(y), !u) {
      var $ = y.clientX - s, I = y.clientY - l;
      u = $ * $ + I * I > h;
    }
    i.mouse("drag", y);
  }
  function d(y) {
    we(y.view).on("mousemove.drag mouseup.drag", null), Zi(y.view, u), it(y), i.mouse("end", y);
  }
  function _(y, $) {
    if (e.call(this, y, $)) {
      var I = y.changedTouches, m = t.call(this, y, $), G = I.length, D, M;
      for (D = 0; D < G; ++D)
        (M = B(this, m, y, $, I[D].identifier, I[D])) && (Nn(y), M("start", y, I[D]));
    }
  }
  function x(y) {
    var $ = y.changedTouches, I = $.length, m, G;
    for (m = 0; m < I; ++m)
      (G = i[$[m].identifier]) && (it(y), G("drag", y, $[m]));
  }
  function N(y) {
    var $ = y.changedTouches, I = $.length, m, G;
    for (c && clearTimeout(c), c = setTimeout(function() {
      c = null;
    }, 500), m = 0; m < I; ++m)
      (G = i[$[m].identifier]) && (Nn(y), G("end", y, $[m]));
  }
  function B(y, $, I, m, G, D) {
    var M = r.copy(), H = Ne(D || I, $), j, te, p;
    if ((p = n.call(y, new Xn("beforestart", {
      sourceEvent: I,
      target: g,
      identifier: G,
      active: a,
      x: H[0],
      y: H[1],
      dx: 0,
      dy: 0,
      dispatch: M
    }), m)) != null)
      return j = p.x - H[0] || 0, te = p.y - H[1] || 0, function R(E, L, U) {
        var W = H, P;
        switch (E) {
          case "start":
            i[G] = R, P = a++;
            break;
          case "end":
            delete i[G], --a;
          case "drag":
            H = Ne(U || L, $), P = a;
            break;
        }
        M.call(
          E,
          y,
          new Xn(E, {
            sourceEvent: L,
            subject: p,
            target: g,
            identifier: G,
            active: P,
            x: H[0] + j,
            y: H[1] + te,
            dx: H[0] - W[0],
            dy: H[1] - W[1],
            dispatch: M
          }),
          m
        );
      };
  }
  return g.filter = function(y) {
    return arguments.length ? (e = typeof y == "function" ? y : It(!!y), g) : e;
  }, g.container = function(y) {
    return arguments.length ? (t = typeof y == "function" ? y : It(y), g) : t;
  }, g.subject = function(y) {
    return arguments.length ? (n = typeof y == "function" ? y : It(y), g) : n;
  }, g.touchable = function(y) {
    return arguments.length ? (o = typeof y == "function" ? y : It(!!y), g) : o;
  }, g.on = function() {
    var y = r.on.apply(r, arguments);
    return y === r ? g : y;
  }, g.clickDistance = function(y) {
    return arguments.length ? (h = (y = +y) * y, g) : Math.sqrt(h);
  }, g;
}
function Ki(e) {
  const t = de(), n = S(t, "vueFlowRef"), o = S(t, "snapToGrid"), i = S(t, "snapGrid"), r = S(t, "noDragClassName"), a = S(t, "nodes"), s = S(t, "nodeExtent"), l = S(t, "viewport"), u = S(t, "autoPanOnNodeDrag"), c = S(t, "nodesDraggable"), h = S(t, "panBy"), g = S(t, "findNode"), w = S(t, "multiSelectionActive"), f = S(t, "nodesSelectionActive"), d = S(t, "selectNodesOnDrag"), _ = S(t, "removeSelectedElements"), x = S(t, "addSelectedNodes"), N = S(t, "updateNodePositions"), B = S(t, "emits"), { onStart: y, onDrag: $, onStop: I, el: m, disabled: G, id: D, selectable: M } = e, H = oe(!1);
  let j = oe([]), te = oe(), p = oe(null), R = oe({ x: void 0, y: void 0 }), E = oe({ x: 0, y: 0 }), L = oe(null), U = oe(0), W = oe(!1), P = oe({ x: 0, y: 0 });
  const K = Aa(), A = ({ x: Z, y: q }) => {
    R.value = { x: Z, y: q };
    let O = !1;
    if (j.value = j.value.map((Y) => {
      const v = { x: Z - Y.distance.x, y: q - Y.distance.y };
      o.value && (v.x = i.value[0] * Math.round(v.x / i.value[0]), v.y = i.value[1] * Math.round(v.y / i.value[1]));
      const { computedPosition: b } = fo(
        Y,
        v,
        B.value.error,
        s.value,
        Y.parentNode ? g.value(Y.parentNode) : void 0
      );
      return O = O || Y.position.x !== b.x || Y.position.y !== b.y, Y.position = b, Y;
    }), !!O && (N.value(j.value, !0, !0), H.value = !0, L.value)) {
      const [Y, v] = Sn({
        id: D,
        dragItems: j.value,
        findNode: g.value
      });
      $({ event: L.value, node: Y, nodes: v });
    }
  }, J = () => {
    if (!p.value)
      return;
    const [Z, q] = Oi(E.value, p.value);
    if (Z !== 0 || q !== 0) {
      const O = {
        x: (R.value.x ?? 0) - Z / l.value.zoom,
        y: (R.value.y ?? 0) - q / l.value.zoom
      };
      h.value({ x: Z, y: q }, (Y) => {
        (Math.round(Y.x) !== Math.round(P.value.x) || Math.round(Y.y) !== Math.round(P.value.y)) && (A(O), P.value = Y, R.value = O);
      });
    }
    U.value = requestAnimationFrame(J);
  };
  return ce([() => se(G), m], ([Z, q]) => {
    if (q) {
      const O = we(q);
      if (Z)
        O.on(".drag", null);
      else {
        const Y = g.value(D);
        te.value = El().on("start", (v) => {
          var F;
          !d.value && !w.value && Y && (Y.selected || _.value()), Y && se(M) && d.value && Gn(
            Y,
            w.value,
            x.value,
            _.value,
            f,
            !1,
            q
          );
          const b = K(v);
          if (R.value = b, j.value = Oa(a.value, c.value, b, g.value, D), j.value.length) {
            const [T, V] = Sn({
              id: D,
              dragItems: j.value,
              findNode: g.value
            });
            y({ event: v.sourceEvent, node: T, nodes: V });
          }
          p.value = ((F = n.value) == null ? void 0 : F.getBoundingClientRect()) || null, E.value = ot(v.sourceEvent, p.value);
        }).on("drag", (v) => {
          const b = K(v);
          !W.value && u.value && (W.value = !0, J()), (R.value.x !== b.xSnapped || R.value.y !== b.ySnapped) && j.value.length && (L.value = v.sourceEvent, E.value = ot(v.sourceEvent, p.value), A(b));
        }).on("end", (v) => {
          if (H.value = !1, W.value = !1, cancelAnimationFrame(U.value), j.value.length) {
            N.value(j.value, !1, !1);
            const [b, F] = Sn({
              id: D,
              dragItems: j.value,
              findNode: g.value
            });
            I({ event: v.sourceEvent, node: b, nodes: F });
          }
        }).filter((v) => {
          const b = v.target;
          return !v.button && (!r.value || !Bo(b, `.${r.value}`, q) && (!(Y != null && Y.dragHandle) || Bo(b, Y.dragHandle, q)));
        }), O.call(te.value);
      }
    }
  }), H;
}
const Wi = "vue-flow__node-desc", qi = "vue-flow__edge-desc", Sl = "vue-flow__aria-live", ji = ["Enter", " ", "Escape"], rt = {
  ArrowUp: { x: 0, y: -1 },
  ArrowDown: { x: 0, y: 1 },
  ArrowLeft: { x: -1, y: 0 },
  ArrowRight: { x: 1, y: 0 }
};
function Un(e) {
  var i, r;
  const t = ((r = (i = e.composedPath) == null ? void 0 : i.call(e)) == null ? void 0 : r[0]) || e.target, n = ze(t.hasAttribute) ? t.hasAttribute("contenteditable") : !1, o = ze(t.closest) ? t.closest(".nokey") : null;
  return ["INPUT", "SELECT", "TEXTAREA"].includes(t == null ? void 0 : t.nodeName) || n || !!o;
}
function Nl(e) {
  return e.ctrlKey || e.metaKey || e.shiftKey;
}
function Cl(e, t) {
  return (n) => e.some((o) => {
    const i = o.split("+").map((r) => r.trim().toLowerCase());
    return i.length === 1 ? n.key === o : (t.add(n.key.toLowerCase()), i.every((r) => t.has(r)));
  });
}
const _t = (e, t) => {
  const n = io(), o = oe(se(e) === !0), i = oe(!1), r = oe(/* @__PURE__ */ new Set());
  return ce(o, () => {
    t == null || t(o.value);
  }), zn(() => {
    let a = se(e);
    if (n && typeof n.addEventListener < "u" && oo(n, "blur", () => {
      o.value = !1;
    }), Tr(a)) {
      o.value = a;
      return;
    }
    Array.isArray(a) && (a = Cl(a, r.value)), a && (So(
      a,
      (s) => {
        i.value = Nl(s), !(!i.value && Un(s)) && (s.preventDefault(), o.value = !0);
      },
      { eventName: "keydown" }
    ), So(
      a,
      (s) => {
        if (o.value) {
          if (!i.value && Un(s))
            return;
          i.value = !1, r.value.clear(), o.value = !1;
        }
      },
      { eventName: "keyup" }
    ));
  }), o;
}, Ml = ge({
  name: "Node",
  compatConfig: { MODE: 3 },
  props: ["name", "type", "id", "draggable", "selectable", "focusable", "connectable", "node", "resizeObserver"],
  setup(e) {
    st(Ni, e.id);
    const t = de(), n = S(t, "id"), o = S(t, "edges"), i = S(t, "noPanClassName"), r = S(t, "selectNodesOnDrag"), a = S(t, "nodesSelectionActive"), s = S(t, "multiSelectionActive"), l = S(t, "emits"), u = S(t, "findNode"), c = S(t, "removeSelectedNodes"), h = S(t, "addSelectedNodes"), g = S(t, "updateNodeDimensions"), w = S(t, "onUpdateNodeInternals"), f = S(t, "getIntersectingNodes"), d = S(t, "getNodeTypes"), _ = S(t, "nodeExtent"), x = S(t, "elevateNodesOnSelect"), N = S(t, "disableKeyboardA11y"), B = S(t, "ariaLiveMessage"), y = S(t, "snapToGrid"), $ = S(t, "snapGrid"), I = Pi(), m = yt(e, "node"), G = ee(() => u.value(m.value.parentNode)), D = ee(() => rn([m.value], o.value)), M = oe();
    st(Ci, M);
    const { emit: H, on: j } = Da(m.value, l.value), te = Ki({
      id: e.id,
      el: M,
      disabled: () => !e.draggable,
      selectable: () => e.selectable,
      onStart(O) {
        H.dragStart({ ...O, intersections: f.value(m.value) });
      },
      onDrag(O) {
        H.drag({ ...O, intersections: f.value(m.value) });
      },
      onStop(O) {
        H.dragStop({ ...O, intersections: f.value(m.value) });
      }
    }), p = ee(() => m.value.class instanceof Function ? m.value.class(m.value) : m.value.class), R = ee(() => {
      const O = (m.value.style instanceof Function ? m.value.style(m.value) : m.value.style) || {}, Y = m.value.width instanceof Function ? m.value.width(m.value) : m.value.width, v = m.value.height instanceof Function ? m.value.height(m.value) : m.value.height;
      return Y && (O.width = typeof Y == "string" ? Y : `${Y}px`), v && (O.height = typeof v == "string" ? v : `${v}px`), O;
    }), E = () => Number(m.value.zIndex ?? R.value.zIndex ?? 0);
    return w.value((O) => {
      O.includes(e.id) && U();
    }), Ve(() => {
      e.resizeObserver.observe(M.value);
    }), di(() => {
      e.resizeObserver.unobserve(M.value);
    }), ce(
      [() => m.value.type, () => m.value.sourcePosition, () => m.value.targetPosition],
      () => {
        g.value([{ id: e.id, nodeElement: M.value, forceUpdate: !0 }]);
      },
      { flush: "pre" }
    ), ce(
      [
        () => m.value.position.x,
        () => m.value.position.y,
        () => {
          var O;
          return (O = G.value) == null ? void 0 : O.computedPosition.x;
        },
        () => {
          var O;
          return (O = G.value) == null ? void 0 : O.computedPosition.y;
        },
        () => {
          var O;
          return (O = G.value) == null ? void 0 : O.computedPosition.z;
        },
        () => E(),
        () => m.value.selected,
        () => m.value.dimensions.height,
        () => m.value.dimensions.width,
        () => {
          var O;
          return (O = G.value) == null ? void 0 : O.dimensions.height;
        },
        () => {
          var O;
          return (O = G.value) == null ? void 0 : O.dimensions.width;
        }
      ],
      ([O, Y, v, b, F, T]) => {
        const V = {
          x: O,
          y: Y,
          z: T + (x.value && m.value.selected ? 1e3 : 0)
        };
        Te(v) && Te(b) ? m.value.computedPosition = ha({ x: v, y: b, z: F }, V) : m.value.computedPosition = V;
      },
      { flush: "pre", immediate: !0 }
    ), ce([() => m.value.extent, () => _.value], ([O, Y], [v, b]) => {
      (O !== v || Y !== b) && L();
    }), m.value.extent === "parent" || typeof m.value.extent == "object" && "range" in m.value.extent && m.value.extent.range === "parent" ? pe(() => m.value.initialized).toBe(!0).then(L) : L(), () => le(
      "div",
      {
        ref: M,
        "data-id": m.value.id,
        class: [
          "vue-flow__node",
          `vue-flow__node-${e.type === !1 ? "default" : e.name}`,
          {
            [i.value]: e.draggable,
            dragging: te == null ? void 0 : te.value,
            selected: m.value.selected,
            selectable: e.selectable
          },
          p.value
        ],
        style: {
          zIndex: m.value.computedPosition.z ?? E(),
          transform: `translate(${m.value.computedPosition.x}px,${m.value.computedPosition.y}px)`,
          pointerEvents: e.selectable || e.draggable ? "all" : "none",
          visibility: m.value.initialized ? "visible" : "hidden",
          ...R.value
        },
        tabIndex: e.focusable ? 0 : void 0,
        role: e.focusable ? "button" : void 0,
        "aria-describedby": N.value ? void 0 : `${Wi}-${n.value}`,
        "aria-label": m.value.ariaLabel,
        onMouseenter: W,
        onMousemove: P,
        onMouseleave: K,
        onContextmenu: A,
        onClick: Z,
        onDblclick: J,
        onKeydown: q
      },
      [
        le(e.type === !1 ? d.value.default : e.type, {
          id: m.value.id,
          type: m.value.type,
          data: m.value.data,
          events: { ...m.value.events, ...j },
          selected: !!m.value.selected,
          resizing: !!m.value.resizing,
          dragging: te.value,
          connectable: e.connectable,
          position: m.value.position,
          dimensions: m.value.dimensions,
          isValidTargetPos: m.value.isValidTargetPos,
          isValidSourcePos: m.value.isValidSourcePos,
          parent: m.value.parentNode,
          zIndex: m.value.computedPosition.z,
          targetPosition: m.value.targetPosition,
          sourcePosition: m.value.sourcePosition,
          label: m.value.label,
          dragHandle: m.value.dragHandle,
          onUpdateNodeInternals: U
        })
      ]
    );
    function L() {
      const O = m.value.computedPosition;
      y.value && (O.x = $.value[0] * Math.round(O.x / $.value[0]), O.y = $.value[1] * Math.round(O.y / $.value[1]));
      const { computedPosition: Y, position: v } = fo(m.value, O, l.value.error, _.value, G.value);
      (m.value.computedPosition.x !== Y.x || m.value.computedPosition.y !== Y.y) && (m.value.computedPosition = { ...m.value.computedPosition, ...Y }), (m.value.position.x !== v.x || m.value.position.y !== v.y) && (m.value.position = v);
    }
    function U() {
      M.value && g.value([{ id: e.id, nodeElement: M.value, forceUpdate: !0 }]);
    }
    function W(O) {
      te != null && te.value || H.mouseEnter({ event: O, node: m.value, connectedEdges: D.value });
    }
    function P(O) {
      te != null && te.value || H.mouseMove({ event: O, node: m.value, connectedEdges: D.value });
    }
    function K(O) {
      te != null && te.value || H.mouseLeave({ event: O, node: m.value, connectedEdges: D.value });
    }
    function A(O) {
      return H.contextMenu({ event: O, node: m.value, connectedEdges: D.value });
    }
    function J(O) {
      return H.doubleClick({ event: O, node: m.value, connectedEdges: D.value });
    }
    function Z(O) {
      e.selectable && (!r.value || !e.draggable) && Gn(
        m.value,
        s.value,
        h.value,
        c.value,
        a,
        !1,
        M.value
      ), H.click({ event: O, node: m.value, connectedEdges: D.value });
    }
    function q(O) {
      var Y;
      if (!Un(O))
        if (ji.includes(O.key) && e.selectable) {
          const v = O.key === "Escape";
          v && ((Y = M.value) == null || Y.blur()), Gn(
            m.value,
            s.value,
            h.value,
            c.value,
            a,
            v,
            M.value
          );
        } else
          !N.value && e.draggable && m.value.selected && rt[O.key] && (B.value = `Moved selected node ${O.key.replace("Arrow", "").toLowerCase()}. New position, x: ${~~m.value.position.x}, y: ${~~m.value.position.y}`, I(
            {
              x: rt[O.key].x,
              y: rt[O.key].y
            },
            O.shiftKey
          ));
    }
  }
}), $l = Ml, kl = ["transform"], Ol = ["width", "height", "x", "y", "rx", "ry"], Il = ["y"], Tl = {
  name: "EdgeText",
  compatConfig: { MODE: 3 }
}, Pl = /* @__PURE__ */ ge({
  ...Tl,
  props: {
    x: null,
    y: null,
    label: null,
    labelStyle: { default: {} },
    labelShowBg: { type: Boolean, default: !0 },
    labelBgStyle: { default: {} },
    labelBgPadding: { default: [2, 4] },
    labelBgBorderRadius: { default: 2 }
  },
  setup(e) {
    let t = oe({ x: 0, y: 0, width: 0, height: 0 });
    const n = oe(null), o = ee(() => `translate(${e.x - t.value.width / 2} ${e.y - t.value.height / 2})`);
    Ve(i), ce([() => e.x, () => e.y, n, () => e.label], i);
    function i() {
      if (!n.value)
        return;
      const r = n.value.getBBox();
      (r.width !== t.value.width || r.height !== t.value.height) && (t.value = r);
    }
    return (r, a) => (ie(), ae("g", {
      transform: k(o),
      class: "vue-flow__edge-textwrapper"
    }, [
      e.labelShowBg ? (ie(), ae("rect", {
        key: 0,
        class: "vue-flow__edge-textbg",
        width: `${k(t).width + 2 * e.labelBgPadding[0]}px`,
        height: `${k(t).height + 2 * e.labelBgPadding[1]}px`,
        x: -e.labelBgPadding[0],
        y: -e.labelBgPadding[1],
        style: Le(e.labelBgStyle),
        rx: e.labelBgBorderRadius,
        ry: e.labelBgBorderRadius
      }, null, 12, Ol)) : Ee("", !0),
      lt("text", fi(r.$attrs, {
        ref_key: "el",
        ref: n,
        class: "vue-flow__edge-text",
        y: k(t).height / 2,
        dy: "0.3em",
        style: e.labelStyle
      }), [
        ye(r.$slots, "default", {}, () => [
          k(Pe)(e.label) ? (ie(), ae(Ce, { key: 1 }, [
            Er(Bn(e.label), 1)
          ], 64)) : (ie(), Ae(hi(e.label), { key: 0 }))
        ])
      ], 16, Il)
    ], 8, kl));
  }
}), fn = function({
  path: e,
  label: t,
  labelX: n,
  labelY: o,
  labelBgBorderRadius: i,
  labelBgPadding: r,
  labelBgStyle: a,
  labelShowBg: s = !0,
  labelStyle: l,
  markerStart: u,
  markerEnd: c,
  interactionWidth: h = 20
}, { attrs: g }) {
  return [
    le("path", {
      style: g.style,
      class: ["vue-flow__edge-path", g.class].join(" "),
      d: e,
      "marker-end": c,
      "marker-start": u
    }),
    h ? le("path", {
      d: e,
      fill: "none",
      "stroke-opacity": 0,
      "stroke-width": h
    }) : null,
    t && Te(n) && Te(o) ? le(Pl, {
      x: n,
      y: o,
      label: t,
      labelStyle: l,
      labelShowBg: s,
      labelBgStyle: a,
      labelBgPadding: r,
      labelBgBorderRadius: i
    }) : null
  ];
};
fn.props = [
  "path",
  "labelX",
  "labelY",
  "label",
  "labelBgBorderRadius",
  "labelBgPadding",
  "labelBgStyle",
  "labelShowBg",
  "labelStyle",
  "markerStart",
  "markerEnd",
  "interactionWidth"
];
fn.inheritAttrs = !1;
fn.compatConfig = { MODE: 3 };
const hn = fn;
function Qi({
  sourceX: e,
  sourceY: t,
  targetX: n,
  targetY: o
}) {
  const i = Math.abs(n - e) / 2, r = n < e ? n + i : n - i, a = Math.abs(o - t) / 2, s = o < t ? o + a : o - a;
  return [r, s, i, a];
}
function Ji({
  sourceX: e,
  sourceY: t,
  targetX: n,
  targetY: o,
  sourceControlX: i,
  sourceControlY: r,
  targetControlX: a,
  targetControlY: s
}) {
  const l = e * 0.125 + i * 0.375 + a * 0.375 + n * 0.125, u = t * 0.125 + r * 0.375 + s * 0.375 + o * 0.125, c = Math.abs(l - e), h = Math.abs(u - t);
  return [l, u, c, h];
}
function Tt(e, t) {
  return e >= 0 ? 0.5 * e : t * 25 * Math.sqrt(-e);
}
function Lo({ pos: e, x1: t, y1: n, x2: o, y2: i, c: r }) {
  let a, s;
  switch (e) {
    case Q.Left:
      a = t - Tt(t - o, r), s = n;
      break;
    case Q.Right:
      a = t + Tt(o - t, r), s = n;
      break;
    case Q.Top:
      a = t, s = n - Tt(n - i, r);
      break;
    case Q.Bottom:
      a = t, s = n + Tt(i - n, r);
      break;
  }
  return [a, s];
}
function Zn({
  sourceX: e,
  sourceY: t,
  sourcePosition: n = Q.Bottom,
  targetX: o,
  targetY: i,
  targetPosition: r = Q.Top,
  curvature: a = 0.25
}) {
  const [s, l] = Lo({
    pos: n,
    x1: e,
    y1: t,
    x2: o,
    y2: i,
    c: a
  }), [u, c] = Lo({
    pos: r,
    x1: o,
    y1: i,
    x2: e,
    y2: t,
    c: a
  }), [h, g, w, f] = Ji({
    sourceX: e,
    sourceY: t,
    targetX: o,
    targetY: i,
    sourceControlX: s,
    sourceControlY: l,
    targetControlX: u,
    targetControlY: c
  });
  return [
    `M${e},${t} C${s},${l} ${u},${c} ${o},${i}`,
    h,
    g,
    w,
    f
  ];
}
const gn = function({ sourcePosition: e = Q.Bottom, targetPosition: t = Q.Top, ...n }, { attrs: o }) {
  const [i, r, a] = Zn({
    sourcePosition: e,
    targetPosition: t,
    ...n
  });
  return le(hn, {
    path: i,
    labelX: r,
    labelY: a,
    ...n,
    ...o
  });
};
gn.props = [
  "sourcePosition",
  "targetPosition",
  "label",
  "labelStyle",
  "labelShowBg",
  "labelBgStyle",
  "labelBgPadding",
  "labelBgBorderRadius",
  "sourceY",
  "sourceX",
  "targetX",
  "targetY",
  "curvature",
  "markerEnd",
  "markerStart",
  "interactionWidth"
];
gn.inheritAttrs = !1;
gn.compatConfig = { MODE: 3 };
const Dl = gn;
function Fo({ pos: e, x1: t, y1: n, x2: o, y2: i }) {
  let r, a;
  switch (e) {
    case Q.Left:
    case Q.Right:
      r = 0.5 * (t + o), a = n;
      break;
    case Q.Top:
    case Q.Bottom:
      r = t, a = 0.5 * (n + i);
      break;
  }
  return [r, a];
}
function er({
  sourceX: e,
  sourceY: t,
  sourcePosition: n = Q.Bottom,
  targetX: o,
  targetY: i,
  targetPosition: r = Q.Top
}) {
  const [a, s] = Fo({
    pos: n,
    x1: e,
    y1: t,
    x2: o,
    y2: i
  }), [l, u] = Fo({
    pos: r,
    x1: o,
    y1: i,
    x2: e,
    y2: t
  }), [c, h, g, w] = Ji({
    sourceX: e,
    sourceY: t,
    targetX: o,
    targetY: i,
    sourceControlX: a,
    sourceControlY: s,
    targetControlX: l,
    targetControlY: u
  });
  return [
    `M${e},${t} C${a},${s} ${l},${u} ${o},${i}`,
    c,
    h,
    g,
    w
  ];
}
const vn = function({ sourcePosition: e = Q.Bottom, targetPosition: t = Q.Top, ...n }, { attrs: o }) {
  const [i, r, a] = er({
    sourcePosition: e,
    targetPosition: t,
    ...n
  });
  return le(hn, {
    path: i,
    labelX: r,
    labelY: a,
    ...n,
    ...o
  });
};
vn.props = [
  "sourcePosition",
  "targetPosition",
  "label",
  "labelStyle",
  "labelShowBg",
  "labelBgStyle",
  "labelBgPadding",
  "labelBgBorderRadius",
  "sourceY",
  "sourceX",
  "targetX",
  "targetY",
  "markerEnd",
  "markerStart",
  "interactionWidth"
];
vn.inheritAttrs = !1;
vn.compatConfig = { MODE: 3 };
const Al = vn, Go = {
  [Q.Left]: { x: -1, y: 0 },
  [Q.Right]: { x: 1, y: 0 },
  [Q.Top]: { x: 0, y: -1 },
  [Q.Bottom]: { x: 0, y: 1 }
};
function zl({
  source: e,
  sourcePosition: t = Q.Bottom,
  target: n
}) {
  return t === Q.Left || t === Q.Right ? e.x < n.x ? { x: 1, y: 0 } : { x: -1, y: 0 } : e.y < n.y ? { x: 0, y: 1 } : { x: 0, y: -1 };
}
function Yo(e, t) {
  return Math.sqrt((t.x - e.x) ** 2 + (t.y - e.y) ** 2);
}
function Bl({
  source: e,
  sourcePosition: t = Q.Bottom,
  target: n,
  targetPosition: o = Q.Top,
  center: i,
  offset: r
}) {
  const a = Go[t], s = Go[o], l = { x: e.x + a.x * r, y: e.y + a.y * r }, u = { x: n.x + s.x * r, y: n.y + s.y * r }, c = zl({
    source: l,
    sourcePosition: t,
    target: u
  }), h = c.x !== 0 ? "x" : "y", g = c[h];
  let w, f, d;
  const [_, x, N, B] = Qi({
    sourceX: e.x,
    sourceY: e.y,
    targetX: n.x,
    targetY: n.y
  });
  if (a[h] * s[h] === -1) {
    f = i.x || _, d = i.y || x;
    const $ = [
      { x: f, y: l.y },
      { x: f, y: u.y }
    ], I = [
      { x: l.x, y: d },
      { x: u.x, y: d }
    ];
    a[h] === g ? w = h === "x" ? $ : I : w = h === "x" ? I : $;
  } else {
    const $ = [{ x: l.x, y: u.y }], I = [{ x: u.x, y: l.y }];
    if (h === "x" ? w = a.x === g ? I : $ : w = a.y === g ? $ : I, t !== o) {
      const m = h === "x" ? "y" : "x", G = a[h] === s[m], D = l[m] > u[m], M = l[m] < u[m];
      (a[h] === 1 && (!G && D || G && M) || a[h] !== 1 && (!G && M || G && D)) && (w = h === "x" ? $ : I);
    }
    f = w[0].x, d = w[0].y;
  }
  return [[e, l, ...w, u, n], f, d, N, B];
}
function Rl(e, t, n, o) {
  const i = Math.min(Yo(e, t) / 2, Yo(t, n) / 2, o), { x: r, y: a } = t;
  if (e.x === r && r === n.x || e.y === a && a === n.y)
    return `L${r} ${a}`;
  if (e.y === a) {
    const u = e.x < n.x ? -1 : 1, c = e.y < n.y ? 1 : -1;
    return `L ${r + i * u},${a}Q ${r},${a} ${r},${a + i * c}`;
  }
  const s = e.x < n.x ? 1 : -1, l = e.y < n.y ? -1 : 1;
  return `L ${r},${a + i * l}Q ${r},${a} ${r + i * s},${a}`;
}
function Kn({
  sourceX: e,
  sourceY: t,
  sourcePosition: n = Q.Bottom,
  targetX: o,
  targetY: i,
  targetPosition: r = Q.Top,
  borderRadius: a = 5,
  centerX: s,
  centerY: l,
  offset: u = 20
}) {
  const [c, h, g, w, f] = Bl({
    source: { x: e, y: t },
    sourcePosition: n,
    target: { x: o, y: i },
    targetPosition: r,
    center: { x: s, y: l },
    offset: u
  });
  return [c.reduce((_, x, N) => {
    let B;
    return N > 0 && N < c.length - 1 ? B = Rl(c[N - 1], x, c[N + 1], a) : B = `${N === 0 ? "M" : "L"}${x.x} ${x.y}`, _ += B, _;
  }, ""), h, g, w, f];
}
const mn = function({ sourcePosition: e = Q.Bottom, targetPosition: t = Q.Top, ...n }, { attrs: o }) {
  const [i, r, a] = Kn({
    sourcePosition: e,
    targetPosition: t,
    ...n
  });
  return le(hn, {
    path: i,
    labelX: r,
    labelY: a,
    ...n,
    ...o
  });
};
mn.props = [
  "sourcePosition",
  "targetPosition",
  "label",
  "labelStyle",
  "labelShowBg",
  "labelBgStyle",
  "labelBgPadding",
  "labelBgBorderRadius",
  "sourceY",
  "sourceX",
  "targetX",
  "targetY",
  "borderRadius",
  "markerEnd",
  "markerStart",
  "interactionWidth",
  "offset"
];
mn.inheritAttrs = !1;
mn.compatConfig = { MODE: 3 };
const tr = mn, pn = function(e, { attrs: t }) {
  return le(tr, { ...e, ...t, borderRadius: 0 });
};
pn.props = [
  "sourcePosition",
  "targetPosition",
  "label",
  "labelStyle",
  "labelShowBg",
  "labelBgStyle",
  "labelBgPadding",
  "labelBgBorderRadius",
  "sourceY",
  "sourceX",
  "targetX",
  "targetY",
  "markerEnd",
  "markerStart",
  "interactionWidth"
];
pn.inheritAttrs = !1;
pn.compatConfig = { MODE: 3 };
const Vl = pn;
function nr({
  sourceX: e,
  sourceY: t,
  targetX: n,
  targetY: o
}) {
  const [i, r, a, s] = Qi({
    sourceX: e,
    sourceY: t,
    targetX: n,
    targetY: o
  });
  return [`M ${e},${t}L ${n},${o}`, i, r, a, s];
}
const yn = function(e, { attrs: t }) {
  const [n, o, i] = nr(e);
  return le(hn, {
    path: n,
    labelX: o,
    labelY: i,
    ...e,
    ...t
  });
};
yn.props = [
  "label",
  "labelStyle",
  "labelShowBg",
  "labelBgStyle",
  "labelBgPadding",
  "labelBgBorderRadius",
  "sourceY",
  "sourceX",
  "targetX",
  "targetY",
  "markerEnd",
  "markerStart",
  "interactionWidth"
];
yn.inheritAttrs = !1;
yn.compatConfig = { MODE: 3 };
const Hl = yn;
function Ll(e, t, n) {
  return n === Q.Left ? e - t : n === Q.Right ? e + t : e;
}
function Fl(e, t, n) {
  return n === Q.Top ? e - t : n === Q.Bottom ? e + t : e;
}
const vo = function({
  radius: e = 10,
  centerX: t = 0,
  centerY: n = 0,
  position: o = Q.Top,
  type: i
}) {
  return le("circle", {
    class: `vue-flow__edgeupdater vue-flow__edgeupdater-${i}`,
    cx: Ll(t, e, o),
    cy: Fl(n, e, o),
    r: e,
    stroke: "transparent",
    fill: "transparent"
  });
};
vo.props = ["radius", "centerX", "centerY", "position", "type"];
vo.compatConfig = { MODE: 3 };
const Xo = vo;
function Gl() {
  return {
    doubleClick: X(),
    click: X(),
    mouseEnter: X(),
    mouseMove: X(),
    mouseLeave: X(),
    contextMenu: X(),
    updateStart: X(),
    update: X(),
    updateEnd: X()
  };
}
function Yl(e, t) {
  const n = Gl();
  return n.doubleClick.on((o) => {
    var i, r;
    t.edgeDoubleClick(o), (r = (i = e.events) == null ? void 0 : i.doubleClick) == null || r.call(i, o);
  }), n.click.on((o) => {
    var i, r;
    t.edgeClick(o), (r = (i = e.events) == null ? void 0 : i.click) == null || r.call(i, o);
  }), n.mouseEnter.on((o) => {
    var i, r;
    t.edgeMouseEnter(o), (r = (i = e.events) == null ? void 0 : i.mouseEnter) == null || r.call(i, o);
  }), n.mouseMove.on((o) => {
    var i, r;
    t.edgeMouseMove(o), (r = (i = e.events) == null ? void 0 : i.mouseMove) == null || r.call(i, o);
  }), n.mouseLeave.on((o) => {
    var i, r;
    t.edgeMouseLeave(o), (r = (i = e.events) == null ? void 0 : i.mouseLeave) == null || r.call(i, o);
  }), n.contextMenu.on((o) => {
    var i, r;
    t.edgeContextMenu(o), (r = (i = e.events) == null ? void 0 : i.contextMenu) == null || r.call(i, o);
  }), n.updateStart.on((o) => {
    var i, r;
    t.edgeUpdateStart(o), (r = (i = e.events) == null ? void 0 : i.updateStart) == null || r.call(i, o);
  }), n.update.on((o) => {
    var i, r;
    t.edgeUpdate(o), (r = (i = e.events) == null ? void 0 : i.update) == null || r.call(i, o);
  }), n.updateEnd.on((o) => {
    var i, r;
    t.edgeUpdateEnd(o), (r = (i = e.events) == null ? void 0 : i.updateEnd) == null || r.call(i, o);
  }), Object.entries(n).reduce(
    (o, [i, r]) => (o.emit[i] = r.trigger, o.on[i] = r.on, o),
    { emit: {}, on: {} }
  );
}
const Xl = ge({
  name: "Edge",
  compatConfig: { MODE: 3 },
  props: ["name", "type", "id", "updatable", "selectable", "focusable", "edge"],
  setup(e) {
    const {
      id: t,
      addSelectedEdges: n,
      connectionMode: o,
      edgeUpdaterRadius: i,
      emits: r,
      nodesSelectionActive: a,
      noPanClassName: s,
      getEdgeTypes: l,
      removeSelectedEdges: u,
      findEdge: c,
      findNode: h,
      isValidConnection: g
    } = de(), w = Yl(e.edge, r), f = yt(e, "edge");
    let d = oe(!1), _ = oe(!1);
    const x = oe(""), N = oe(null), B = oe("source"), y = oe();
    st(Mi, e.id), st($i, y);
    const $ = ee(() => f.value.class instanceof Function ? f.value.class(f.value) : f.value.class), I = ee(() => f.value.style instanceof Function ? f.value.style(f.value) : f.value.style), { handlePointerDown: m } = Ii({
      nodeId: x,
      handleId: N,
      type: B,
      isValidConnection: g.value,
      edgeUpdaterType: B,
      onEdgeUpdate: M,
      onEdgeUpdateEnd: H
    });
    return () => {
      const A = h(f.value.source), J = h(f.value.target);
      if (!A || !J || !f.value)
        return null;
      let Z;
      o.value === je.Strict ? Z = A.handleBounds.source : Z = [...A.handleBounds.source || [], ...A.handleBounds.target || []];
      const q = Po(Z, f.value.sourceHandle);
      let O;
      o.value === je.Strict ? O = J.handleBounds.target : O = [...J.handleBounds.target || [], ...J.handleBounds.source || []];
      const Y = Po(O, f.value.targetHandle), v = q ? q.position : Q.Bottom, b = Y ? Y.position : Q.Top, { sourceX: F, sourceY: T, targetY: V, targetX: C } = ya(
        A,
        q,
        v,
        J,
        Y,
        b
      );
      return f.value.sourceX = F, f.value.sourceY = T, f.value.targetX = C, f.value.targetY = V, le(
        "g",
        {
          ref: y,
          key: e.id,
          "data-id": e.id,
          class: [
            "vue-flow__edge",
            `vue-flow__edge-${e.type === !1 ? "default" : e.name}`,
            s.value,
            $.value,
            {
              updating: d.value,
              selected: f.value.selected,
              animated: f.value.animated,
              inactive: !e.selectable
            }
          ],
          onClick: te,
          onContextmenu: p,
          onDblclick: R,
          onMouseenter: E,
          onMousemove: L,
          onMouseleave: U,
          onKeyDown: e.focusable ? K : void 0,
          tabIndex: e.focusable ? 0 : void 0,
          "aria-label": f.value.ariaLabel === null ? void 0 : f.value.ariaLabel || `Edge from ${f.value.source} to ${f.value.target}`,
          "aria-describedby": e.focusable ? `${qi}-${t}` : void 0,
          role: e.focusable ? "button" : void 0
        },
        [
          _.value ? null : le(e.type === !1 ? l.value.default : e.type, {
            id: e.id,
            sourceNode: A,
            targetNode: J,
            source: f.value.source,
            target: f.value.target,
            type: f.value.type,
            updatable: e.updatable,
            selected: f.value.selected,
            animated: f.value.animated,
            label: f.value.label,
            labelStyle: f.value.labelStyle,
            labelShowBg: f.value.labelShowBg,
            labelBgStyle: f.value.labelBgStyle,
            labelBgPadding: f.value.labelBgPadding,
            labelBgBorderRadius: f.value.labelBgBorderRadius,
            data: f.value.data,
            events: { ...f.value.events, ...w.on },
            style: I.value,
            markerStart: `url(#${Xe(f.value.markerStart, t)})`,
            markerEnd: `url(#${Xe(f.value.markerEnd, t)})`,
            sourcePosition: v,
            targetPosition: b,
            sourceX: F,
            sourceY: T,
            targetX: C,
            targetY: V,
            sourceHandleId: f.value.sourceHandle,
            targetHandleId: f.value.targetHandle,
            interactionWidth: f.value.interactionWidth
          }),
          [
            e.updatable === "source" || e.updatable === !0 ? [
              le(
                "g",
                {
                  onMousedown: W,
                  onMouseenter: G,
                  onMouseout: D
                },
                le(Xo, {
                  position: v,
                  centerX: F,
                  centerY: T,
                  radius: i.value,
                  type: "source",
                  "data-type": "source"
                })
              )
            ] : null,
            e.updatable === "target" || e.updatable === !0 ? [
              le(
                "g",
                {
                  onMousedown: P,
                  onMouseenter: G,
                  onMouseout: D
                },
                le(Xo, {
                  position: b,
                  centerX: C,
                  centerY: V,
                  radius: i.value,
                  type: "target",
                  "data-type": "target"
                })
              )
            ] : null
          ]
        ]
      );
    };
    function G() {
      d.value = !0;
    }
    function D() {
      d.value = !1;
    }
    function M(A, J) {
      w.emit.update({ event: A, edge: f.value, connection: J });
    }
    function H(A) {
      w.emit.updateEnd({ event: A, edge: f.value }), _.value = !1;
    }
    function j(A, J) {
      A.button === 0 && (_.value = !0, x.value = J ? f.value.target : f.value.source, N.value = (J ? f.value.targetHandle : f.value.sourceHandle) ?? "", B.value = J ? "target" : "source", w.emit.updateStart({ event: A, edge: f.value }), m(A));
    }
    function te(A) {
      const J = { event: A, edge: f.value };
      e.selectable && (a.value = !1, n([f.value])), w.emit.click(J);
    }
    function p(A) {
      w.emit.contextMenu({ event: A, edge: f.value });
    }
    function R(A) {
      w.emit.doubleClick({ event: A, edge: f.value });
    }
    function E(A) {
      w.emit.mouseEnter({ event: A, edge: f.value });
    }
    function L(A) {
      w.emit.mouseMove({ event: A, edge: f.value });
    }
    function U(A) {
      w.emit.mouseLeave({ event: A, edge: f.value });
    }
    function W(A) {
      j(A, !0);
    }
    function P(A) {
      j(A, !1);
    }
    function K(A) {
      var J;
      ji.includes(A.key) && e.selectable && (A.key === "Escape" ? ((J = y.value) == null || J.blur(), u([c(e.id)])) : n([c(e.id)]));
    }
  }
}), Ul = Xl, Zl = {
  height: "0",
  width: "0"
}, Kl = {
  name: "EdgeLabelRenderer",
  compatConfig: { MODE: 3 }
}, Ad = /* @__PURE__ */ ge({
  ...Kl,
  setup(e) {
    const { viewportRef: t } = de(), n = ee(() => {
      var o;
      return (o = t.value) == null ? void 0 : o.getElementsByClassName("vue-flow__edge-labels")[0];
    });
    return (o, i) => (ie(), ae("svg", null, [
      (ie(), ae("foreignObject", Zl, [
        (ie(), Ae(Sr, {
          to: k(n),
          disabled: !k(n)
        }, [
          ye(o.$slots, "default")
        ], 8, ["to", "disabled"]))
      ]))
    ]));
  }
}), Wl = { class: "vue-flow__connection" }, ql = ["d", "marker-end", "marker-start"], jl = {
  name: "ConnectionLine",
  compatConfig: { MODE: 3 }
}, Ql = /* @__PURE__ */ ge({
  ...jl,
  props: {
    sourceNode: null
  },
  setup(e) {
    var D;
    const t = de(), n = S(t, "connectionMode"), o = S(t, "connectionStartHandle"), i = S(t, "connectionEndHandle"), r = S(t, "connectionPosition"), a = S(t, "connectionLineType"), s = S(t, "connectionLineStyle"), l = S(t, "connectionLineOptions"), u = S(t, "connectionStatus"), c = S(t, "viewport"), h = S(t, "findNode"), g = {
      [Q.Left]: Q.Right,
      [Q.Right]: Q.Left,
      [Q.Top]: Q.Bottom,
      [Q.Bottom]: Q.Top
    }, w = (D = He(an)) == null ? void 0 : D["connection-line"], f = ee(() => o.value.handleId), d = ee(() => o.value.type), _ = ee(() => {
      var M;
      return ((M = i.value) == null ? void 0 : M.handleId) && h.value(i.value.nodeId) || null;
    }), x = ee(
      () => {
        var M, H;
        return (n.value === je.Strict ? (M = e.sourceNode.handleBounds[d.value]) == null ? void 0 : M.find((j) => j.id === f.value) : [...e.sourceNode.handleBounds.source || [], ...e.sourceNode.handleBounds.target || []].find((j) => j.id === f.value)) || ((H = e.sourceNode.handleBounds[d.value ?? "source"]) == null ? void 0 : H[0]);
      }
    ), N = ee(() => {
      var M, H, j;
      return _.value && ((M = i.value) == null ? void 0 : M.handleId) && ((n.value === je.Strict ? (H = _.value.handleBounds[d.value === "source" ? "target" : "source"]) == null ? void 0 : H.find(
        (te) => {
          var p;
          return te.id === ((p = i.value) == null ? void 0 : p.handleId);
        }
      ) : [..._.value.handleBounds.source || [], ..._.value.handleBounds.target || []].find(
        (te) => {
          var p;
          return te.id === ((p = i.value) == null ? void 0 : p.handleId);
        }
      )) || ((j = _.value.handleBounds[d.value ?? "target"]) == null ? void 0 : j[0])) || null;
    }), B = ee(() => {
      var M;
      return (M = x.value) == null ? void 0 : M.position;
    }), y = ee(() => x.value ? Ut(
      B.value || Q.Top,
      { ...e.sourceNode.dimensions, ...e.sourceNode.computedPosition },
      x.value
    ) : {
      x: e.sourceNode.dimensions.width / 2,
      y: e.sourceNode.dimensions.height / 2
    }), $ = ee(() => B.value ? g[B.value] : void 0), I = ee(() => (r.value.x - c.value.x) / c.value.zoom), m = ee(() => (r.value.y - c.value.y) / c.value.zoom), G = ee(() => {
      let M;
      const H = {
        sourceX: y.value.x,
        sourceY: y.value.y,
        sourcePosition: B.value,
        targetX: I.value,
        targetY: m.value,
        targetPosition: $.value
      };
      switch (a.value ?? l.value.type) {
        case Ye.Bezier:
          [M] = Zn(H);
          break;
        case Ye.Step:
          [M] = Kn({
            ...H,
            borderRadius: 0
          });
          break;
        case Ye.SmoothStep:
          [M] = Kn(H);
          break;
        case Ye.SimpleBezier:
          [M] = er(H);
          break;
        case Ye.Straight:
          [M] = nr(H);
          break;
        default:
          [M] = Zn(H);
          break;
      }
      return M;
    });
    return (M, H) => {
      var j;
      return ie(), ae("g", Wl, [
        k(w) ? (ie(), Ae(hi(k(w)), Nr(fi({ key: 0 }, {
          sourceX: k(y).x,
          sourceY: k(y).y,
          sourcePosition: (j = k(x)) == null ? void 0 : j.position,
          targetX: k(I),
          targetY: k(m),
          targetPosition: k($),
          sourceNode: e.sourceNode,
          sourceHandle: k(x),
          targetNode: k(_),
          targetHandle: k(N),
          markerEnd: `url(#${k(Xe)(k(l).markerEnd)})`,
          markerStart: `url(#${k(Xe)(k(l).markerStart)})`,
          connectionStatus: k(u)
        })), null, 16)) : (ie(), ae("path", {
          key: 1,
          d: k(G),
          class: We(["vue-flow__connection-path", [k(l).class, k(u)]]),
          style: Le(k(s) || k(l).style || {}),
          "marker-end": `url(#${k(Xe)(k(l).markerEnd)})`,
          "marker-start": `url(#${k(Xe)(k(l).markerStart)})`
        }, null, 14, ql))
      ]);
    };
  }
}), Jl = ["tabIndex"], eu = {
  name: "NodesSelection",
  compatConfig: { MODE: 3 }
}, tu = /* @__PURE__ */ ge({
  ...eu,
  setup(e) {
    const t = de(), n = S(t, "emits"), o = S(t, "viewport"), i = S(t, "getSelectedNodes"), r = S(t, "noPanClassName"), a = S(t, "disableKeyboardA11y"), s = S(t, "userSelectionActive"), l = Pi(), u = oe(), c = Ki({
      el: u,
      onStart(d) {
        n.value.selectionDragStart(d);
      },
      onDrag(d) {
        n.value.selectionDrag(d);
      },
      onStop(d) {
        n.value.selectionDragStop(d);
      }
    });
    Ve(() => {
      var d;
      a.value || (d = u.value) == null || d.focus({ preventScroll: !0 });
    });
    const h = ee(() => lo(i.value)), g = ee(() => ({
      width: `${h.value.width}px`,
      height: `${h.value.height}px`,
      top: `${h.value.y}px`,
      left: `${h.value.x}px`
    }));
    function w(d) {
      n.value.selectionContextMenu({ event: d, nodes: i.value });
    }
    function f(d) {
      a.value || rt[d.key] && l(
        {
          x: rt[d.key].x,
          y: rt[d.key].y
        },
        d.shiftKey
      );
    }
    return (d, _) => !k(s) && k(h).width && k(h).height ? (ie(), ae("div", {
      key: 0,
      class: We(["vue-flow__nodesselection vue-flow__container", k(r)]),
      style: Le({ transform: `translate(${k(o).x}px,${k(o).y}px) scale(${k(o).zoom})` })
    }, [
      lt("div", {
        ref_key: "el",
        ref: u,
        class: We([{ dragging: k(c) }, "vue-flow__nodesselection-rect"]),
        style: Le(k(g)),
        tabIndex: k(a) ? void 0 : -1,
        onContextmenu: w,
        onKeydown: f
      }, null, 46, Jl)
    ], 6)) : Ee("", !0);
  }
}), nu = {
  name: "UserSelection",
  compatConfig: { MODE: 3 }
}, ou = /* @__PURE__ */ ge({
  ...nu,
  setup(e) {
    const { userSelectionRect: t } = de();
    return (n, o) => {
      var i, r, a, s;
      return ie(), ae("div", {
        class: "vue-flow__selection vue-flow__container",
        style: Le({
          width: `${(i = k(t)) == null ? void 0 : i.width}px`,
          height: `${(r = k(t)) == null ? void 0 : r.height}px`,
          transform: `translate(${(a = k(t)) == null ? void 0 : a.x}px, ${(s = k(t)) == null ? void 0 : s.y}px)`
        })
      }, null, 4);
    };
  }
}), iu = {
  input: $a,
  default: Ma,
  output: ka
}, ru = {
  default: Dl,
  straight: Hl,
  step: Vl,
  smoothstep: tr,
  simplebezier: Al
};
function au() {
  return {
    vueFlowRef: null,
    viewportRef: null,
    nodes: [],
    edges: [],
    nodeTypes: {},
    edgeTypes: {},
    initialized: !1,
    dimensions: {
      width: 0,
      height: 0
    },
    viewport: { x: 0, y: 0, zoom: 1 },
    d3Zoom: null,
    d3Selection: null,
    d3ZoomHandler: null,
    minZoom: 0.5,
    maxZoom: 2,
    translateExtent: [
      [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
      [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
    ],
    nodeExtent: [
      [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
      [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
    ],
    selectionMode: uo.Full,
    paneDragging: !1,
    preventScrolling: !0,
    zoomOnScroll: !0,
    zoomOnPinch: !0,
    zoomOnDoubleClick: !0,
    panOnScroll: !1,
    panOnScrollSpeed: 0.5,
    panOnScrollMode: Xt.Free,
    panOnDrag: !0,
    edgeUpdaterRadius: 10,
    onlyRenderVisibleElements: !1,
    defaultViewport: { x: 0, y: 0, zoom: 1 },
    nodesSelectionActive: !1,
    userSelectionActive: !1,
    userSelectionRect: null,
    defaultMarkerColor: "#b1b1b7",
    connectionLineStyle: {},
    connectionLineType: null,
    connectionLineOptions: {
      type: Ye.Bezier,
      style: {}
    },
    connectionMode: je.Loose,
    connectionStartHandle: null,
    connectionEndHandle: null,
    connectionClickStartHandle: null,
    connectionPosition: { x: NaN, y: NaN },
    connectionRadius: 20,
    connectOnClick: !0,
    connectionStatus: null,
    isValidConnection: null,
    snapGrid: [15, 15],
    snapToGrid: !1,
    edgesUpdatable: !1,
    edgesFocusable: !0,
    nodesFocusable: !0,
    nodesConnectable: !0,
    nodesDraggable: !0,
    elementsSelectable: !0,
    selectNodesOnDrag: !0,
    multiSelectionActive: !1,
    selectionKeyCode: "Shift",
    multiSelectionKeyCode: "Meta",
    zoomActivationKeyCode: "Meta",
    deleteKeyCode: "Backspace",
    panActivationKeyCode: "Space",
    hooks: sa(),
    applyDefault: !0,
    autoConnect: !1,
    fitViewOnInit: !1,
    noDragClassName: "nodrag",
    noWheelClassName: "nowheel",
    noPanClassName: "nopan",
    defaultEdgeOptions: void 0,
    elevateEdgesOnSelect: !1,
    elevateNodesOnSelect: !0,
    autoPanOnNodeDrag: !0,
    autoPanOnConnect: !0,
    disableKeyboardA11y: !1,
    ariaLiveMessage: "",
    __experimentalFeatures: {
      nestedFlow: !1
    }
  };
}
function or(e) {
  const t = au();
  return e && Object.keys(e).forEach((n) => {
    const o = e[n];
    ue(o) && (t[n] = o);
  }), t;
}
function su(e, t, n) {
  const o = ee(() => (d) => e.nodes && !t.value.length ? e.nodes.find((_) => _.id === d) : e.nodes[t.value.indexOf(d)]), i = ee(() => (d) => e.edges && !n.value.length ? e.edges.find((_) => _.id === d) : e.edges[n.value.indexOf(d)]), r = ee(() => {
    var x;
    const d = {
      ...ru,
      ...e.edgeTypes
    }, _ = Object.keys(d);
    return (x = e.edges) == null || x.forEach((N) => N.type && !_.includes(N.type) && (d[N.type] = N.type)), d;
  }), a = ee(() => {
    var x;
    const d = {
      ...iu,
      ...e.nodeTypes
    }, _ = Object.keys(d);
    return (x = e.nodes) == null || x.forEach((N) => N.type && !_.includes(N.type) && (d[N.type] = N.type)), d;
  }), s = ee(() => {
    const d = e.nodes.filter((_) => !_.hidden);
    return e.onlyRenderVisibleElements ? d && Ei(
      d,
      {
        x: 0,
        y: 0,
        width: e.dimensions.width,
        height: e.dimensions.height
      },
      e.viewport,
      !0
    ) : d ?? [];
  }), l = (d, _, x) => {
    if (_ = _ ?? o.value(d.source), x = x ?? o.value(d.target), !_ || !x) {
      e.hooks.error.trigger(new ve(he.EDGE_ORPHANED, d.id));
      return;
    }
    return !d.hidden && !x.hidden && !_.hidden;
  }, u = ee(() => e.onlyRenderVisibleElements ? e.edges.filter((d) => {
    const _ = o.value(d.source), x = o.value(d.target);
    return l(d, _, x) && xa({
      sourcePos: _.computedPosition || { x: 0, y: 0 },
      targetPos: x.computedPosition || { x: 0, y: 0 },
      sourceWidth: _.dimensions.width,
      sourceHeight: _.dimensions.height,
      targetWidth: x.dimensions.width,
      targetHeight: x.dimensions.height,
      width: e.dimensions.width,
      height: e.dimensions.height,
      viewport: e.viewport
    });
  }) : e.edges.filter((d) => l(d))), c = ee(() => [...s.value, ...u.value]), h = ee(() => e.nodes.filter((d) => d.selected)), g = ee(() => e.edges.filter((d) => d.selected)), w = ee(() => [
    ...h.value ?? [],
    ...g.value ?? []
  ]), f = ee(
    () => s.value.filter((d) => d.initialized && d.handleBounds !== void 0)
  );
  return {
    getNode: o,
    getEdge: i,
    getElements: c,
    getEdgeTypes: r,
    getNodeTypes: a,
    getEdges: u,
    getNodes: s,
    getSelectedElements: w,
    getSelectedNodes: h,
    getSelectedEdges: g,
    getNodesInitialized: f
  };
}
function mo(e, t, n) {
  e.prototype = t.prototype = n, n.constructor = e;
}
function ir(e, t) {
  var n = Object.create(e.prototype);
  for (var o in t)
    n[o] = t[o];
  return n;
}
function kt() {
}
var Et = 0.7, Wt = 1 / Et, at = "\\s*([+-]?\\d+)\\s*", St = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Me = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", lu = /^#([0-9a-f]{3,8})$/, uu = new RegExp(`^rgb\\(${at},${at},${at}\\)$`), cu = new RegExp(`^rgb\\(${Me},${Me},${Me}\\)$`), du = new RegExp(`^rgba\\(${at},${at},${at},${St}\\)$`), fu = new RegExp(`^rgba\\(${Me},${Me},${Me},${St}\\)$`), hu = new RegExp(`^hsl\\(${St},${Me},${Me}\\)$`), gu = new RegExp(`^hsla\\(${St},${Me},${Me},${St}\\)$`), Uo = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
mo(kt, Nt, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: Zo,
  // Deprecated! Use color.formatHex.
  formatHex: Zo,
  formatHex8: vu,
  formatHsl: mu,
  formatRgb: Ko,
  toString: Ko
});
function Zo() {
  return this.rgb().formatHex();
}
function vu() {
  return this.rgb().formatHex8();
}
function mu() {
  return rr(this).formatHsl();
}
function Ko() {
  return this.rgb().formatRgb();
}
function Nt(e) {
  var t, n;
  return e = (e + "").trim().toLowerCase(), (t = lu.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? Wo(t) : n === 3 ? new me(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? Pt(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? Pt(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = uu.exec(e)) ? new me(t[1], t[2], t[3], 1) : (t = cu.exec(e)) ? new me(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = du.exec(e)) ? Pt(t[1], t[2], t[3], t[4]) : (t = fu.exec(e)) ? Pt(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = hu.exec(e)) ? Qo(t[1], t[2] / 100, t[3] / 100, 1) : (t = gu.exec(e)) ? Qo(t[1], t[2] / 100, t[3] / 100, t[4]) : Uo.hasOwnProperty(e) ? Wo(Uo[e]) : e === "transparent" ? new me(NaN, NaN, NaN, 0) : null;
}
function Wo(e) {
  return new me(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function Pt(e, t, n, o) {
  return o <= 0 && (e = t = n = NaN), new me(e, t, n, o);
}
function pu(e) {
  return e instanceof kt || (e = Nt(e)), e ? (e = e.rgb(), new me(e.r, e.g, e.b, e.opacity)) : new me();
}
function Wn(e, t, n, o) {
  return arguments.length === 1 ? pu(e) : new me(e, t, n, o ?? 1);
}
function me(e, t, n, o) {
  this.r = +e, this.g = +t, this.b = +n, this.opacity = +o;
}
mo(me, Wn, ir(kt, {
  brighter(e) {
    return e = e == null ? Wt : Math.pow(Wt, e), new me(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Et : Math.pow(Et, e), new me(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new me(Ke(this.r), Ke(this.g), Ke(this.b), qt(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: qo,
  // Deprecated! Use color.formatHex.
  formatHex: qo,
  formatHex8: yu,
  formatRgb: jo,
  toString: jo
}));
function qo() {
  return `#${Ue(this.r)}${Ue(this.g)}${Ue(this.b)}`;
}
function yu() {
  return `#${Ue(this.r)}${Ue(this.g)}${Ue(this.b)}${Ue((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function jo() {
  const e = qt(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${Ke(this.r)}, ${Ke(this.g)}, ${Ke(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function qt(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function Ke(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function Ue(e) {
  return e = Ke(e), (e < 16 ? "0" : "") + e.toString(16);
}
function Qo(e, t, n, o) {
  return o <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new be(e, t, n, o);
}
function rr(e) {
  if (e instanceof be)
    return new be(e.h, e.s, e.l, e.opacity);
  if (e instanceof kt || (e = Nt(e)), !e)
    return new be();
  if (e instanceof be)
    return e;
  e = e.rgb();
  var t = e.r / 255, n = e.g / 255, o = e.b / 255, i = Math.min(t, n, o), r = Math.max(t, n, o), a = NaN, s = r - i, l = (r + i) / 2;
  return s ? (t === r ? a = (n - o) / s + (n < o) * 6 : n === r ? a = (o - t) / s + 2 : a = (t - n) / s + 4, s /= l < 0.5 ? r + i : 2 - r - i, a *= 60) : s = l > 0 && l < 1 ? 0 : a, new be(a, s, l, e.opacity);
}
function xu(e, t, n, o) {
  return arguments.length === 1 ? rr(e) : new be(e, t, n, o ?? 1);
}
function be(e, t, n, o) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +o;
}
mo(be, xu, ir(kt, {
  brighter(e) {
    return e = e == null ? Wt : Math.pow(Wt, e), new be(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Et : Math.pow(Et, e), new be(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, o = n + (n < 0.5 ? n : 1 - n) * t, i = 2 * n - o;
    return new me(
      Cn(e >= 240 ? e - 240 : e + 120, i, o),
      Cn(e, i, o),
      Cn(e < 120 ? e + 240 : e - 120, i, o),
      this.opacity
    );
  },
  clamp() {
    return new be(Jo(this.h), Dt(this.s), Dt(this.l), qt(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = qt(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${Jo(this.h)}, ${Dt(this.s) * 100}%, ${Dt(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function Jo(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function Dt(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function Cn(e, t, n) {
  return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
}
const ar = (e) => () => e;
function _u(e, t) {
  return function(n) {
    return e + n * t;
  };
}
function wu(e, t, n) {
  return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(o) {
    return Math.pow(e + o * t, n);
  };
}
function bu(e) {
  return (e = +e) == 1 ? sr : function(t, n) {
    return n - t ? wu(t, n, e) : ar(isNaN(t) ? n : t);
  };
}
function sr(e, t) {
  var n = t - e;
  return n ? _u(e, n) : ar(isNaN(e) ? t : e);
}
const ei = function e(t) {
  var n = bu(t);
  function o(i, r) {
    var a = n((i = Wn(i)).r, (r = Wn(r)).r), s = n(i.g, r.g), l = n(i.b, r.b), u = sr(i.opacity, r.opacity);
    return function(c) {
      return i.r = a(c), i.g = s(c), i.b = l(c), i.opacity = u(c), i + "";
    };
  }
  return o.gamma = e, o;
}(1);
function Re(e, t) {
  return e = +e, t = +t, function(n) {
    return e * (1 - n) + t * n;
  };
}
var qn = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, Mn = new RegExp(qn.source, "g");
function Eu(e) {
  return function() {
    return e;
  };
}
function Su(e) {
  return function(t) {
    return e(t) + "";
  };
}
function Nu(e, t) {
  var n = qn.lastIndex = Mn.lastIndex = 0, o, i, r, a = -1, s = [], l = [];
  for (e = e + "", t = t + ""; (o = qn.exec(e)) && (i = Mn.exec(t)); )
    (r = i.index) > n && (r = t.slice(n, r), s[a] ? s[a] += r : s[++a] = r), (o = o[0]) === (i = i[0]) ? s[a] ? s[a] += i : s[++a] = i : (s[++a] = null, l.push({ i: a, x: Re(o, i) })), n = Mn.lastIndex;
  return n < t.length && (r = t.slice(n), s[a] ? s[a] += r : s[++a] = r), s.length < 2 ? l[0] ? Su(l[0].x) : Eu(t) : (t = l.length, function(u) {
    for (var c = 0, h; c < t; ++c)
      s[(h = l[c]).i] = h.x(u);
    return s.join("");
  });
}
var ti = 180 / Math.PI, jn = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function lr(e, t, n, o, i, r) {
  var a, s, l;
  return (a = Math.sqrt(e * e + t * t)) && (e /= a, t /= a), (l = e * n + t * o) && (n -= e * l, o -= t * l), (s = Math.sqrt(n * n + o * o)) && (n /= s, o /= s, l /= s), e * o < t * n && (e = -e, t = -t, l = -l, a = -a), {
    translateX: i,
    translateY: r,
    rotate: Math.atan2(t, e) * ti,
    skewX: Math.atan(l) * ti,
    scaleX: a,
    scaleY: s
  };
}
var At;
function Cu(e) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
  return t.isIdentity ? jn : lr(t.a, t.b, t.c, t.d, t.e, t.f);
}
function Mu(e) {
  return e == null || (At || (At = document.createElementNS("http://www.w3.org/2000/svg", "g")), At.setAttribute("transform", e), !(e = At.transform.baseVal.consolidate())) ? jn : (e = e.matrix, lr(e.a, e.b, e.c, e.d, e.e, e.f));
}
function ur(e, t, n, o) {
  function i(u) {
    return u.length ? u.pop() + " " : "";
  }
  function r(u, c, h, g, w, f) {
    if (u !== h || c !== g) {
      var d = w.push("translate(", null, t, null, n);
      f.push({ i: d - 4, x: Re(u, h) }, { i: d - 2, x: Re(c, g) });
    } else
      (h || g) && w.push("translate(" + h + t + g + n);
  }
  function a(u, c, h, g) {
    u !== c ? (u - c > 180 ? c += 360 : c - u > 180 && (u += 360), g.push({ i: h.push(i(h) + "rotate(", null, o) - 2, x: Re(u, c) })) : c && h.push(i(h) + "rotate(" + c + o);
  }
  function s(u, c, h, g) {
    u !== c ? g.push({ i: h.push(i(h) + "skewX(", null, o) - 2, x: Re(u, c) }) : c && h.push(i(h) + "skewX(" + c + o);
  }
  function l(u, c, h, g, w, f) {
    if (u !== h || c !== g) {
      var d = w.push(i(w) + "scale(", null, ",", null, ")");
      f.push({ i: d - 4, x: Re(u, h) }, { i: d - 2, x: Re(c, g) });
    } else
      (h !== 1 || g !== 1) && w.push(i(w) + "scale(" + h + "," + g + ")");
  }
  return function(u, c) {
    var h = [], g = [];
    return u = e(u), c = e(c), r(u.translateX, u.translateY, c.translateX, c.translateY, h, g), a(u.rotate, c.rotate, h, g), s(u.skewX, c.skewX, h, g), l(u.scaleX, u.scaleY, c.scaleX, c.scaleY, h, g), u = c = null, function(w) {
      for (var f = -1, d = g.length, _; ++f < d; )
        h[(_ = g[f]).i] = _.x(w);
      return h.join("");
    };
  };
}
var $u = ur(Cu, "px, ", "px)", "deg)"), ku = ur(Mu, ", ", ")", ")"), Ou = 1e-12;
function ni(e) {
  return ((e = Math.exp(e)) + 1 / e) / 2;
}
function Iu(e) {
  return ((e = Math.exp(e)) - 1 / e) / 2;
}
function Tu(e) {
  return ((e = Math.exp(2 * e)) - 1) / (e + 1);
}
const Pu = function e(t, n, o) {
  function i(r, a) {
    var s = r[0], l = r[1], u = r[2], c = a[0], h = a[1], g = a[2], w = c - s, f = h - l, d = w * w + f * f, _, x;
    if (d < Ou)
      x = Math.log(g / u) / t, _ = function(m) {
        return [
          s + m * w,
          l + m * f,
          u * Math.exp(t * m * x)
        ];
      };
    else {
      var N = Math.sqrt(d), B = (g * g - u * u + o * d) / (2 * u * n * N), y = (g * g - u * u - o * d) / (2 * g * n * N), $ = Math.log(Math.sqrt(B * B + 1) - B), I = Math.log(Math.sqrt(y * y + 1) - y);
      x = (I - $) / t, _ = function(m) {
        var G = m * x, D = ni($), M = u / (n * N) * (D * Tu(t * G + $) - Iu($));
        return [
          s + M * w,
          l + M * f,
          u * D / ni(t * G + $)
        ];
      };
    }
    return _.duration = x * 1e3 * t / Math.SQRT2, _;
  }
  return i.rho = function(r) {
    var a = Math.max(1e-3, +r), s = a * a, l = s * s;
    return e(a, s, l);
  }, i;
}(Math.SQRT2, 2, 4);
var ft = 0, mt = 0, gt = 0, cr = 1e3, jt, pt, Qt = 0, Qe = 0, xn = 0, Ct = typeof performance == "object" && performance.now ? performance : Date, dr = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function po() {
  return Qe || (dr(Du), Qe = Ct.now() + xn);
}
function Du() {
  Qe = 0;
}
function Jt() {
  this._call = this._time = this._next = null;
}
Jt.prototype = fr.prototype = {
  constructor: Jt,
  restart: function(e, t, n) {
    if (typeof e != "function")
      throw new TypeError("callback is not a function");
    n = (n == null ? po() : +n) + (t == null ? 0 : +t), !this._next && pt !== this && (pt ? pt._next = this : jt = this, pt = this), this._call = e, this._time = n, Qn();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, Qn());
  }
};
function fr(e, t, n) {
  var o = new Jt();
  return o.restart(e, t, n), o;
}
function Au() {
  po(), ++ft;
  for (var e = jt, t; e; )
    (t = Qe - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
  --ft;
}
function oi() {
  Qe = (Qt = Ct.now()) + xn, ft = mt = 0;
  try {
    Au();
  } finally {
    ft = 0, Bu(), Qe = 0;
  }
}
function zu() {
  var e = Ct.now(), t = e - Qt;
  t > cr && (xn -= t, Qt = e);
}
function Bu() {
  for (var e, t = jt, n, o = 1 / 0; t; )
    t._call ? (o > t._time && (o = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : jt = n);
  pt = e, Qn(o);
}
function Qn(e) {
  if (!ft) {
    mt && (mt = clearTimeout(mt));
    var t = e - Qe;
    t > 24 ? (e < 1 / 0 && (mt = setTimeout(oi, e - Ct.now() - xn)), gt && (gt = clearInterval(gt))) : (gt || (Qt = Ct.now(), gt = setInterval(zu, cr)), ft = 1, dr(oi));
  }
}
function ii(e, t, n) {
  var o = new Jt();
  return t = t == null ? 0 : +t, o.restart((i) => {
    o.stop(), e(i + t);
  }, t, n), o;
}
var Ru = cn("start", "end", "cancel", "interrupt"), Vu = [], hr = 0, ri = 1, Jn = 2, Vt = 3, ai = 4, eo = 5, Ht = 6;
function _n(e, t, n, o, i, r) {
  var a = e.__transition;
  if (!a)
    e.__transition = {};
  else if (n in a)
    return;
  Hu(e, n, {
    name: t,
    index: o,
    // For context during callback.
    group: i,
    // For context during callback.
    on: Ru,
    tween: Vu,
    time: r.time,
    delay: r.delay,
    duration: r.duration,
    ease: r.ease,
    timer: null,
    state: hr
  });
}
function yo(e, t) {
  var n = Se(e, t);
  if (n.state > hr)
    throw new Error("too late; already scheduled");
  return n;
}
function ke(e, t) {
  var n = Se(e, t);
  if (n.state > Vt)
    throw new Error("too late; already running");
  return n;
}
function Se(e, t) {
  var n = e.__transition;
  if (!n || !(n = n[t]))
    throw new Error("transition not found");
  return n;
}
function Hu(e, t, n) {
  var o = e.__transition, i;
  o[t] = n, n.timer = fr(r, 0, n.time);
  function r(u) {
    n.state = ri, n.timer.restart(a, n.delay, n.time), n.delay <= u && a(u - n.delay);
  }
  function a(u) {
    var c, h, g, w;
    if (n.state !== ri)
      return l();
    for (c in o)
      if (w = o[c], w.name === n.name) {
        if (w.state === Vt)
          return ii(a);
        w.state === ai ? (w.state = Ht, w.timer.stop(), w.on.call("interrupt", e, e.__data__, w.index, w.group), delete o[c]) : +c < t && (w.state = Ht, w.timer.stop(), w.on.call("cancel", e, e.__data__, w.index, w.group), delete o[c]);
      }
    if (ii(function() {
      n.state === Vt && (n.state = ai, n.timer.restart(s, n.delay, n.time), s(u));
    }), n.state = Jn, n.on.call("start", e, e.__data__, n.index, n.group), n.state === Jn) {
      for (n.state = Vt, i = new Array(g = n.tween.length), c = 0, h = -1; c < g; ++c)
        (w = n.tween[c].value.call(e, e.__data__, n.index, n.group)) && (i[++h] = w);
      i.length = h + 1;
    }
  }
  function s(u) {
    for (var c = u < n.duration ? n.ease.call(null, u / n.duration) : (n.timer.restart(l), n.state = eo, 1), h = -1, g = i.length; ++h < g; )
      i[h].call(e, c);
    n.state === eo && (n.on.call("end", e, e.__data__, n.index, n.group), l());
  }
  function l() {
    n.state = Ht, n.timer.stop(), delete o[t];
    for (var u in o)
      return;
    delete e.__transition;
  }
}
function Lt(e, t) {
  var n = e.__transition, o, i, r = !0, a;
  if (n) {
    t = t == null ? null : t + "";
    for (a in n) {
      if ((o = n[a]).name !== t) {
        r = !1;
        continue;
      }
      i = o.state > Jn && o.state < eo, o.state = Ht, o.timer.stop(), o.on.call(i ? "interrupt" : "cancel", e, e.__data__, o.index, o.group), delete n[a];
    }
    r && delete e.__transition;
  }
}
function Lu(e) {
  return this.each(function() {
    Lt(this, e);
  });
}
function Fu(e, t) {
  var n, o;
  return function() {
    var i = ke(this, e), r = i.tween;
    if (r !== n) {
      o = n = r;
      for (var a = 0, s = o.length; a < s; ++a)
        if (o[a].name === t) {
          o = o.slice(), o.splice(a, 1);
          break;
        }
    }
    i.tween = o;
  };
}
function Gu(e, t, n) {
  var o, i;
  if (typeof n != "function")
    throw new Error();
  return function() {
    var r = ke(this, e), a = r.tween;
    if (a !== o) {
      i = (o = a).slice();
      for (var s = { name: t, value: n }, l = 0, u = i.length; l < u; ++l)
        if (i[l].name === t) {
          i[l] = s;
          break;
        }
      l === u && i.push(s);
    }
    r.tween = i;
  };
}
function Yu(e, t) {
  var n = this._id;
  if (e += "", arguments.length < 2) {
    for (var o = Se(this.node(), n).tween, i = 0, r = o.length, a; i < r; ++i)
      if ((a = o[i]).name === e)
        return a.value;
    return null;
  }
  return this.each((t == null ? Fu : Gu)(n, e, t));
}
function xo(e, t, n) {
  var o = e._id;
  return e.each(function() {
    var i = ke(this, o);
    (i.value || (i.value = {}))[t] = n.apply(this, arguments);
  }), function(i) {
    return Se(i, o).value[t];
  };
}
function gr(e, t) {
  var n;
  return (typeof t == "number" ? Re : t instanceof Nt ? ei : (n = Nt(t)) ? (t = n, ei) : Nu)(e, t);
}
function Xu(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function Uu(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function Zu(e, t, n) {
  var o, i = n + "", r;
  return function() {
    var a = this.getAttribute(e);
    return a === i ? null : a === o ? r : r = t(o = a, n);
  };
}
function Ku(e, t, n) {
  var o, i = n + "", r;
  return function() {
    var a = this.getAttributeNS(e.space, e.local);
    return a === i ? null : a === o ? r : r = t(o = a, n);
  };
}
function Wu(e, t, n) {
  var o, i, r;
  return function() {
    var a, s = n(this), l;
    return s == null ? void this.removeAttribute(e) : (a = this.getAttribute(e), l = s + "", a === l ? null : a === o && l === i ? r : (i = l, r = t(o = a, s)));
  };
}
function qu(e, t, n) {
  var o, i, r;
  return function() {
    var a, s = n(this), l;
    return s == null ? void this.removeAttributeNS(e.space, e.local) : (a = this.getAttributeNS(e.space, e.local), l = s + "", a === l ? null : a === o && l === i ? r : (i = l, r = t(o = a, s)));
  };
}
function ju(e, t) {
  var n = dn(e), o = n === "transform" ? ku : gr;
  return this.attrTween(e, typeof t == "function" ? (n.local ? qu : Wu)(n, o, xo(this, "attr." + e, t)) : t == null ? (n.local ? Uu : Xu)(n) : (n.local ? Ku : Zu)(n, o, t));
}
function Qu(e, t) {
  return function(n) {
    this.setAttribute(e, t.call(this, n));
  };
}
function Ju(e, t) {
  return function(n) {
    this.setAttributeNS(e.space, e.local, t.call(this, n));
  };
}
function ec(e, t) {
  var n, o;
  function i() {
    var r = t.apply(this, arguments);
    return r !== o && (n = (o = r) && Ju(e, r)), n;
  }
  return i._value = t, i;
}
function tc(e, t) {
  var n, o;
  function i() {
    var r = t.apply(this, arguments);
    return r !== o && (n = (o = r) && Qu(e, r)), n;
  }
  return i._value = t, i;
}
function nc(e, t) {
  var n = "attr." + e;
  if (arguments.length < 2)
    return (n = this.tween(n)) && n._value;
  if (t == null)
    return this.tween(n, null);
  if (typeof t != "function")
    throw new Error();
  var o = dn(e);
  return this.tween(n, (o.local ? ec : tc)(o, t));
}
function oc(e, t) {
  return function() {
    yo(this, e).delay = +t.apply(this, arguments);
  };
}
function ic(e, t) {
  return t = +t, function() {
    yo(this, e).delay = t;
  };
}
function rc(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? oc : ic)(t, e)) : Se(this.node(), t).delay;
}
function ac(e, t) {
  return function() {
    ke(this, e).duration = +t.apply(this, arguments);
  };
}
function sc(e, t) {
  return t = +t, function() {
    ke(this, e).duration = t;
  };
}
function lc(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? ac : sc)(t, e)) : Se(this.node(), t).duration;
}
function uc(e, t) {
  if (typeof t != "function")
    throw new Error();
  return function() {
    ke(this, e).ease = t;
  };
}
function cc(e) {
  var t = this._id;
  return arguments.length ? this.each(uc(t, e)) : Se(this.node(), t).ease;
}
function dc(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    if (typeof n != "function")
      throw new Error();
    ke(this, e).ease = n;
  };
}
function fc(e) {
  if (typeof e != "function")
    throw new Error();
  return this.each(dc(this._id, e));
}
function hc(e) {
  typeof e != "function" && (e = zi(e));
  for (var t = this._groups, n = t.length, o = new Array(n), i = 0; i < n; ++i)
    for (var r = t[i], a = r.length, s = o[i] = [], l, u = 0; u < a; ++u)
      (l = r[u]) && e.call(l, l.__data__, u, r) && s.push(l);
  return new Be(o, this._parents, this._name, this._id);
}
function gc(e) {
  if (e._id !== this._id)
    throw new Error();
  for (var t = this._groups, n = e._groups, o = t.length, i = n.length, r = Math.min(o, i), a = new Array(o), s = 0; s < r; ++s)
    for (var l = t[s], u = n[s], c = l.length, h = a[s] = new Array(c), g, w = 0; w < c; ++w)
      (g = l[w] || u[w]) && (h[w] = g);
  for (; s < o; ++s)
    a[s] = t[s];
  return new Be(a, this._parents, this._name, this._id);
}
function vc(e) {
  return (e + "").trim().split(/^|\s+/).every(function(t) {
    var n = t.indexOf(".");
    return n >= 0 && (t = t.slice(0, n)), !t || t === "start";
  });
}
function mc(e, t, n) {
  var o, i, r = vc(t) ? yo : ke;
  return function() {
    var a = r(this, e), s = a.on;
    s !== o && (i = (o = s).copy()).on(t, n), a.on = i;
  };
}
function pc(e, t) {
  var n = this._id;
  return arguments.length < 2 ? Se(this.node(), n).on.on(e) : this.each(mc(n, e, t));
}
function yc(e) {
  return function() {
    var t = this.parentNode;
    for (var n in this.__transition)
      if (+n !== e)
        return;
    t && t.removeChild(this);
  };
}
function xc() {
  return this.on("end.remove", yc(this._id));
}
function _c(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = ho(e));
  for (var o = this._groups, i = o.length, r = new Array(i), a = 0; a < i; ++a)
    for (var s = o[a], l = s.length, u = r[a] = new Array(l), c, h, g = 0; g < l; ++g)
      (c = s[g]) && (h = e.call(c, c.__data__, g, s)) && ("__data__" in c && (h.__data__ = c.__data__), u[g] = h, _n(u[g], t, n, g, u, Se(c, n)));
  return new Be(r, this._parents, t, n);
}
function wc(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = Ai(e));
  for (var o = this._groups, i = o.length, r = [], a = [], s = 0; s < i; ++s)
    for (var l = o[s], u = l.length, c, h = 0; h < u; ++h)
      if (c = l[h]) {
        for (var g = e.call(c, c.__data__, h, l), w, f = Se(c, n), d = 0, _ = g.length; d < _; ++d)
          (w = g[d]) && _n(w, t, n, d, g, f);
        r.push(g), a.push(c);
      }
  return new Be(r, a, t, n);
}
var bc = $t.prototype.constructor;
function Ec() {
  return new bc(this._groups, this._parents);
}
function Sc(e, t) {
  var n, o, i;
  return function() {
    var r = dt(this, e), a = (this.style.removeProperty(e), dt(this, e));
    return r === a ? null : r === n && a === o ? i : i = t(n = r, o = a);
  };
}
function vr(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function Nc(e, t, n) {
  var o, i = n + "", r;
  return function() {
    var a = dt(this, e);
    return a === i ? null : a === o ? r : r = t(o = a, n);
  };
}
function Cc(e, t, n) {
  var o, i, r;
  return function() {
    var a = dt(this, e), s = n(this), l = s + "";
    return s == null && (l = s = (this.style.removeProperty(e), dt(this, e))), a === l ? null : a === o && l === i ? r : (i = l, r = t(o = a, s));
  };
}
function Mc(e, t) {
  var n, o, i, r = "style." + t, a = "end." + r, s;
  return function() {
    var l = ke(this, e), u = l.on, c = l.value[r] == null ? s || (s = vr(t)) : void 0;
    (u !== n || i !== c) && (o = (n = u).copy()).on(a, i = c), l.on = o;
  };
}
function $c(e, t, n) {
  var o = (e += "") == "transform" ? $u : gr;
  return t == null ? this.styleTween(e, Sc(e, o)).on("end.style." + e, vr(e)) : typeof t == "function" ? this.styleTween(e, Cc(e, o, xo(this, "style." + e, t))).each(Mc(this._id, e)) : this.styleTween(e, Nc(e, o, t), n).on("end.style." + e, null);
}
function kc(e, t, n) {
  return function(o) {
    this.style.setProperty(e, t.call(this, o), n);
  };
}
function Oc(e, t, n) {
  var o, i;
  function r() {
    var a = t.apply(this, arguments);
    return a !== i && (o = (i = a) && kc(e, a, n)), o;
  }
  return r._value = t, r;
}
function Ic(e, t, n) {
  var o = "style." + (e += "");
  if (arguments.length < 2)
    return (o = this.tween(o)) && o._value;
  if (t == null)
    return this.tween(o, null);
  if (typeof t != "function")
    throw new Error();
  return this.tween(o, Oc(e, t, n ?? ""));
}
function Tc(e) {
  return function() {
    this.textContent = e;
  };
}
function Pc(e) {
  return function() {
    var t = e(this);
    this.textContent = t ?? "";
  };
}
function Dc(e) {
  return this.tween("text", typeof e == "function" ? Pc(xo(this, "text", e)) : Tc(e == null ? "" : e + ""));
}
function Ac(e) {
  return function(t) {
    this.textContent = e.call(this, t);
  };
}
function zc(e) {
  var t, n;
  function o() {
    var i = e.apply(this, arguments);
    return i !== n && (t = (n = i) && Ac(i)), t;
  }
  return o._value = e, o;
}
function Bc(e) {
  var t = "text";
  if (arguments.length < 1)
    return (t = this.tween(t)) && t._value;
  if (e == null)
    return this.tween(t, null);
  if (typeof e != "function")
    throw new Error();
  return this.tween(t, zc(e));
}
function Rc() {
  for (var e = this._name, t = this._id, n = mr(), o = this._groups, i = o.length, r = 0; r < i; ++r)
    for (var a = o[r], s = a.length, l, u = 0; u < s; ++u)
      if (l = a[u]) {
        var c = Se(l, t);
        _n(l, e, n, u, a, {
          time: c.time + c.delay + c.duration,
          delay: 0,
          duration: c.duration,
          ease: c.ease
        });
      }
  return new Be(o, this._parents, e, n);
}
function Vc() {
  var e, t, n = this, o = n._id, i = n.size();
  return new Promise(function(r, a) {
    var s = { value: a }, l = { value: function() {
      --i === 0 && r();
    } };
    n.each(function() {
      var u = ke(this, o), c = u.on;
      c !== e && (t = (e = c).copy(), t._.cancel.push(s), t._.interrupt.push(s), t._.end.push(l)), u.on = t;
    }), i === 0 && r();
  });
}
var Hc = 0;
function Be(e, t, n, o) {
  this._groups = e, this._parents = t, this._name = n, this._id = o;
}
function mr() {
  return ++Hc;
}
var Oe = $t.prototype;
Be.prototype = {
  constructor: Be,
  select: _c,
  selectAll: wc,
  selectChild: Oe.selectChild,
  selectChildren: Oe.selectChildren,
  filter: hc,
  merge: gc,
  selection: Ec,
  transition: Rc,
  call: Oe.call,
  nodes: Oe.nodes,
  node: Oe.node,
  size: Oe.size,
  empty: Oe.empty,
  each: Oe.each,
  on: pc,
  attr: ju,
  attrTween: nc,
  style: $c,
  styleTween: Ic,
  text: Dc,
  textTween: Bc,
  remove: xc,
  tween: Yu,
  delay: rc,
  duration: lc,
  ease: cc,
  easeVarying: fc,
  end: Vc,
  [Symbol.iterator]: Oe[Symbol.iterator]
};
function Lc(e) {
  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
}
var Fc = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: Lc
};
function Gc(e, t) {
  for (var n; !(n = e.__transition) || !(n = n[t]); )
    if (!(e = e.parentNode))
      throw new Error(`transition ${t} not found`);
  return n;
}
function Yc(e) {
  var t, n;
  e instanceof Be ? (t = e._id, e = e._name) : (t = mr(), (n = Fc).time = po(), e = e == null ? null : e + "");
  for (var o = this._groups, i = o.length, r = 0; r < i; ++r)
    for (var a = o[r], s = a.length, l, u = 0; u < s; ++u)
      (l = a[u]) && _n(l, e, t, u, a, n || Gc(l, t));
  return new Be(o, this._parents, e, t);
}
$t.prototype.interrupt = Lu;
$t.prototype.transition = Yc;
const zt = (e) => () => e;
function Xc(e, {
  sourceEvent: t,
  target: n,
  transform: o,
  dispatch: i
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    transform: { value: o, enumerable: !0, configurable: !0 },
    _: { value: i }
  });
}
function De(e, t, n) {
  this.k = e, this.x = t, this.y = n;
}
De.prototype = {
  constructor: De,
  scale: function(e) {
    return e === 1 ? this : new De(this.k * e, this.x, this.y);
  },
  translate: function(e, t) {
    return e === 0 & t === 0 ? this : new De(this.k, this.x + this.k * e, this.y + this.k * t);
  },
  apply: function(e) {
    return [e[0] * this.k + this.x, e[1] * this.k + this.y];
  },
  applyX: function(e) {
    return e * this.k + this.x;
  },
  applyY: function(e) {
    return e * this.k + this.y;
  },
  invert: function(e) {
    return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k];
  },
  invertX: function(e) {
    return (e - this.x) / this.k;
  },
  invertY: function(e) {
    return (e - this.y) / this.k;
  },
  rescaleX: function(e) {
    return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e));
  },
  rescaleY: function(e) {
    return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var ht = new De(1, 0, 0);
De.prototype;
function $n(e) {
  e.stopImmediatePropagation();
}
function vt(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function Uc(e) {
  return (!e.ctrlKey || e.type === "wheel") && !e.button;
}
function Zc() {
  var e = this;
  return e instanceof SVGElement ? (e = e.ownerSVGElement || e, e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]]) : [[0, 0], [e.clientWidth, e.clientHeight]];
}
function si() {
  return this.__zoom || ht;
}
function Kc(e) {
  return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * (e.ctrlKey ? 10 : 1);
}
function Wc() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function qc(e, t, n) {
  var o = e.invertX(t[0][0]) - n[0][0], i = e.invertX(t[1][0]) - n[1][0], r = e.invertY(t[0][1]) - n[0][1], a = e.invertY(t[1][1]) - n[1][1];
  return e.translate(
    i > o ? (o + i) / 2 : Math.min(0, o) || Math.max(0, i),
    a > r ? (r + a) / 2 : Math.min(0, r) || Math.max(0, a)
  );
}
function jc() {
  var e = Uc, t = Zc, n = qc, o = Kc, i = Wc, r = [0, 1 / 0], a = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], s = 250, l = Pu, u = cn("start", "zoom", "end"), c, h, g, w = 500, f = 150, d = 0, _ = 10;
  function x(p) {
    p.property("__zoom", si).on("wheel.zoom", G, { passive: !1 }).on("mousedown.zoom", D).on("dblclick.zoom", M).filter(i).on("touchstart.zoom", H).on("touchmove.zoom", j).on("touchend.zoom touchcancel.zoom", te).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  x.transform = function(p, R, E, L) {
    var U = p.selection ? p.selection() : p;
    U.property("__zoom", si), p !== U ? $(p, R, E, L) : U.interrupt().each(function() {
      I(this, arguments).event(L).start().zoom(null, typeof R == "function" ? R.apply(this, arguments) : R).end();
    });
  }, x.scaleBy = function(p, R, E, L) {
    x.scaleTo(p, function() {
      var U = this.__zoom.k, W = typeof R == "function" ? R.apply(this, arguments) : R;
      return U * W;
    }, E, L);
  }, x.scaleTo = function(p, R, E, L) {
    x.transform(p, function() {
      var U = t.apply(this, arguments), W = this.__zoom, P = E == null ? y(U) : typeof E == "function" ? E.apply(this, arguments) : E, K = W.invert(P), A = typeof R == "function" ? R.apply(this, arguments) : R;
      return n(B(N(W, A), P, K), U, a);
    }, E, L);
  }, x.translateBy = function(p, R, E, L) {
    x.transform(p, function() {
      return n(this.__zoom.translate(
        typeof R == "function" ? R.apply(this, arguments) : R,
        typeof E == "function" ? E.apply(this, arguments) : E
      ), t.apply(this, arguments), a);
    }, null, L);
  }, x.translateTo = function(p, R, E, L, U) {
    x.transform(p, function() {
      var W = t.apply(this, arguments), P = this.__zoom, K = L == null ? y(W) : typeof L == "function" ? L.apply(this, arguments) : L;
      return n(ht.translate(K[0], K[1]).scale(P.k).translate(
        typeof R == "function" ? -R.apply(this, arguments) : -R,
        typeof E == "function" ? -E.apply(this, arguments) : -E
      ), W, a);
    }, L, U);
  };
  function N(p, R) {
    return R = Math.max(r[0], Math.min(r[1], R)), R === p.k ? p : new De(R, p.x, p.y);
  }
  function B(p, R, E) {
    var L = R[0] - E[0] * p.k, U = R[1] - E[1] * p.k;
    return L === p.x && U === p.y ? p : new De(p.k, L, U);
  }
  function y(p) {
    return [(+p[0][0] + +p[1][0]) / 2, (+p[0][1] + +p[1][1]) / 2];
  }
  function $(p, R, E, L) {
    p.on("start.zoom", function() {
      I(this, arguments).event(L).start();
    }).on("interrupt.zoom end.zoom", function() {
      I(this, arguments).event(L).end();
    }).tween("zoom", function() {
      var U = this, W = arguments, P = I(U, W).event(L), K = t.apply(U, W), A = E == null ? y(K) : typeof E == "function" ? E.apply(U, W) : E, J = Math.max(K[1][0] - K[0][0], K[1][1] - K[0][1]), Z = U.__zoom, q = typeof R == "function" ? R.apply(U, W) : R, O = l(Z.invert(A).concat(J / Z.k), q.invert(A).concat(J / q.k));
      return function(Y) {
        if (Y === 1)
          Y = q;
        else {
          var v = O(Y), b = J / v[2];
          Y = new De(b, A[0] - v[0] * b, A[1] - v[1] * b);
        }
        P.zoom(null, Y);
      };
    });
  }
  function I(p, R, E) {
    return !E && p.__zooming || new m(p, R);
  }
  function m(p, R) {
    this.that = p, this.args = R, this.active = 0, this.sourceEvent = null, this.extent = t.apply(p, R), this.taps = 0;
  }
  m.prototype = {
    event: function(p) {
      return p && (this.sourceEvent = p), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(p, R) {
      return this.mouse && p !== "mouse" && (this.mouse[1] = R.invert(this.mouse[0])), this.touch0 && p !== "touch" && (this.touch0[1] = R.invert(this.touch0[0])), this.touch1 && p !== "touch" && (this.touch1[1] = R.invert(this.touch1[0])), this.that.__zoom = R, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(p) {
      var R = we(this.that).datum();
      u.call(
        p,
        this.that,
        new Xc(p, {
          sourceEvent: this.sourceEvent,
          target: x,
          type: p,
          transform: this.that.__zoom,
          dispatch: u
        }),
        R
      );
    }
  };
  function G(p, ...R) {
    if (!e.apply(this, arguments))
      return;
    var E = I(this, R).event(p), L = this.__zoom, U = Math.max(r[0], Math.min(r[1], L.k * Math.pow(2, o.apply(this, arguments)))), W = Ne(p);
    if (E.wheel)
      (E.mouse[0][0] !== W[0] || E.mouse[0][1] !== W[1]) && (E.mouse[1] = L.invert(E.mouse[0] = W)), clearTimeout(E.wheel);
    else {
      if (L.k === U)
        return;
      E.mouse = [W, L.invert(W)], Lt(this), E.start();
    }
    vt(p), E.wheel = setTimeout(P, f), E.zoom("mouse", n(B(N(L, U), E.mouse[0], E.mouse[1]), E.extent, a));
    function P() {
      E.wheel = null, E.end();
    }
  }
  function D(p, ...R) {
    if (g || !e.apply(this, arguments))
      return;
    var E = p.currentTarget, L = I(this, R, !0).event(p), U = we(p.view).on("mousemove.zoom", A, !0).on("mouseup.zoom", J, !0), W = Ne(p, E), P = p.clientX, K = p.clientY;
    Ui(p.view), $n(p), L.mouse = [W, this.__zoom.invert(W)], Lt(this), L.start();
    function A(Z) {
      if (vt(Z), !L.moved) {
        var q = Z.clientX - P, O = Z.clientY - K;
        L.moved = q * q + O * O > d;
      }
      L.event(Z).zoom("mouse", n(B(L.that.__zoom, L.mouse[0] = Ne(Z, E), L.mouse[1]), L.extent, a));
    }
    function J(Z) {
      U.on("mousemove.zoom mouseup.zoom", null), Zi(Z.view, L.moved), vt(Z), L.event(Z).end();
    }
  }
  function M(p, ...R) {
    if (e.apply(this, arguments)) {
      var E = this.__zoom, L = Ne(p.changedTouches ? p.changedTouches[0] : p, this), U = E.invert(L), W = E.k * (p.shiftKey ? 0.5 : 2), P = n(B(N(E, W), L, U), t.apply(this, R), a);
      vt(p), s > 0 ? we(this).transition().duration(s).call($, P, L, p) : we(this).call(x.transform, P, L, p);
    }
  }
  function H(p, ...R) {
    if (e.apply(this, arguments)) {
      var E = p.touches, L = E.length, U = I(this, R, p.changedTouches.length === L).event(p), W, P, K, A;
      for ($n(p), P = 0; P < L; ++P)
        K = E[P], A = Ne(K, this), A = [A, this.__zoom.invert(A), K.identifier], U.touch0 ? !U.touch1 && U.touch0[2] !== A[2] && (U.touch1 = A, U.taps = 0) : (U.touch0 = A, W = !0, U.taps = 1 + !!c);
      c && (c = clearTimeout(c)), W && (U.taps < 2 && (h = A[0], c = setTimeout(function() {
        c = null;
      }, w)), Lt(this), U.start());
    }
  }
  function j(p, ...R) {
    if (this.__zooming) {
      var E = I(this, R).event(p), L = p.changedTouches, U = L.length, W, P, K, A;
      for (vt(p), W = 0; W < U; ++W)
        P = L[W], K = Ne(P, this), E.touch0 && E.touch0[2] === P.identifier ? E.touch0[0] = K : E.touch1 && E.touch1[2] === P.identifier && (E.touch1[0] = K);
      if (P = E.that.__zoom, E.touch1) {
        var J = E.touch0[0], Z = E.touch0[1], q = E.touch1[0], O = E.touch1[1], Y = (Y = q[0] - J[0]) * Y + (Y = q[1] - J[1]) * Y, v = (v = O[0] - Z[0]) * v + (v = O[1] - Z[1]) * v;
        P = N(P, Math.sqrt(Y / v)), K = [(J[0] + q[0]) / 2, (J[1] + q[1]) / 2], A = [(Z[0] + O[0]) / 2, (Z[1] + O[1]) / 2];
      } else if (E.touch0)
        K = E.touch0[0], A = E.touch0[1];
      else
        return;
      E.zoom("touch", n(B(P, K, A), E.extent, a));
    }
  }
  function te(p, ...R) {
    if (this.__zooming) {
      var E = I(this, R).event(p), L = p.changedTouches, U = L.length, W, P;
      for ($n(p), g && clearTimeout(g), g = setTimeout(function() {
        g = null;
      }, w), W = 0; W < U; ++W)
        P = L[W], E.touch0 && E.touch0[2] === P.identifier ? delete E.touch0 : E.touch1 && E.touch1[2] === P.identifier && delete E.touch1;
      if (E.touch1 && !E.touch0 && (E.touch0 = E.touch1, delete E.touch1), E.touch0)
        E.touch0[1] = this.__zoom.invert(E.touch0[0]);
      else if (E.end(), E.taps === 2 && (P = Ne(P, this), Math.hypot(h[0] - P[0], h[1] - P[1]) < _)) {
        var K = we(this).on("dblclick.zoom");
        K && K.apply(this, arguments);
      }
    }
  }
  return x.wheelDelta = function(p) {
    return arguments.length ? (o = typeof p == "function" ? p : zt(+p), x) : o;
  }, x.filter = function(p) {
    return arguments.length ? (e = typeof p == "function" ? p : zt(!!p), x) : e;
  }, x.touchable = function(p) {
    return arguments.length ? (i = typeof p == "function" ? p : zt(!!p), x) : i;
  }, x.extent = function(p) {
    return arguments.length ? (t = typeof p == "function" ? p : zt([[+p[0][0], +p[0][1]], [+p[1][0], +p[1][1]]]), x) : t;
  }, x.scaleExtent = function(p) {
    return arguments.length ? (r[0] = +p[0], r[1] = +p[1], x) : [r[0], r[1]];
  }, x.translateExtent = function(p) {
    return arguments.length ? (a[0][0] = +p[0][0], a[1][0] = +p[1][0], a[0][1] = +p[0][1], a[1][1] = +p[1][1], x) : [[a[0][0], a[0][1]], [a[1][0], a[1][1]]];
  }, x.constrain = function(p) {
    return arguments.length ? (n = p, x) : n;
  }, x.duration = function(p) {
    return arguments.length ? (s = +p, x) : s;
  }, x.interpolate = function(p) {
    return arguments.length ? (l = p, x) : l;
  }, x.on = function() {
    var p = u.on.apply(u, arguments);
    return p === u ? x : p;
  }, x.clickDistance = function(p) {
    return arguments.length ? (d = (p = +p) * p, x) : Math.sqrt(d);
  }, x.tapDistance = function(p) {
    return arguments.length ? (_ = +p, x) : _;
  }, x;
}
const kn = 0.1;
function Fe() {
}
const Qc = {
  zoomIn: Fe,
  zoomOut: Fe,
  zoomTo: Fe,
  fitView: Fe,
  setCenter: Fe,
  fitBounds: Fe,
  project: (e) => e,
  setTransform: Fe,
  getTransform: () => ({ x: 0, y: 0, zoom: 1 }),
  initialized: !1
}, Jc = (e, t) => {
  const n = e, o = S(n, "nodes"), i = S(n, "d3Zoom"), r = S(n, "d3Selection"), a = S(n, "dimensions"), s = S(n, "translateExtent"), l = S(n, "minZoom"), u = S(n, "maxZoom"), c = S(n, "viewport"), h = S(n, "snapToGrid"), g = S(n, "snapGrid"), w = S(n, "hooks"), f = t, d = S(f, "getNodes"), _ = oe(!1);
  w.value.nodesInitialized.on(() => {
    _.value = !0;
  });
  const x = ee(() => !!i.value && !!r.value && !!a.value.width && !!a.value.height && _.value);
  function N(y, $) {
    r.value && i.value && i.value.scaleBy(On(r.value, $), y);
  }
  function B(y, $, I, m) {
    const { x: G, y: D } = ro({ x: -y, y: -$ }, s.value), M = ht.translate(-G, -D).scale(I);
    r.value && i.value && i.value.transform(On(r.value, m), M);
  }
  return ee(() => x.value ? {
    initialized: !0,
    zoomIn: (y) => {
      N(1.2, y == null ? void 0 : y.duration);
    },
    zoomOut: (y) => {
      N(1 / 1.2, y == null ? void 0 : y.duration);
    },
    zoomTo: (y, $) => {
      r.value && i.value && i.value.scaleTo(On(r.value, $ == null ? void 0 : $.duration), y);
    },
    setTransform: (y, $) => {
      B(y.x, y.y, y.zoom, $ == null ? void 0 : $.duration);
    },
    getTransform: () => ({
      x: c.value.x,
      y: c.value.y,
      zoom: c.value.zoom
    }),
    fitView: (y = {
      padding: kn,
      includeHiddenNodes: !1,
      duration: 0
    }) => {
      if (!o.value.length)
        return;
      const $ = (y.includeHiddenNodes ? o.value : d.value).filter((M) => {
        var te;
        const H = M.initialized && M.dimensions.width && M.dimensions.height;
        let j = !0;
        return (te = y.nodes) != null && te.length && (j = y.nodes.includes(M.id)), H && j;
      }), I = lo($), { x: m, y: G, zoom: D } = Yt(
        I,
        a.value.width,
        a.value.height,
        y.minZoom ?? l.value,
        y.maxZoom ?? u.value,
        y.padding ?? kn,
        y.offset
      );
      B(m, G, D, y == null ? void 0 : y.duration);
    },
    setCenter: (y, $, I) => {
      const m = typeof (I == null ? void 0 : I.zoom) < "u" ? I.zoom : u.value, G = a.value.width / 2 - y * m, D = a.value.height / 2 - $ * m;
      B(G, D, m, I == null ? void 0 : I.duration);
    },
    fitBounds: (y, $ = { padding: kn }) => {
      const { x: I, y: m, zoom: G } = Yt(
        y,
        a.value.width,
        a.value.height,
        l.value,
        u.value,
        $.padding
      );
      B(I, m, G, $ == null ? void 0 : $.duration);
    },
    project: (y) => so(y, c.value, h.value, g.value)
  } : Qc);
};
function On(e, t = 0) {
  return e.transition().duration(t);
}
function In(e, t) {
  if (t) {
    const n = e.position.x + e.dimensions.width - t.dimensions.width, o = e.position.y + e.dimensions.height - t.dimensions.height;
    if (n > 0 || o > 0 || e.position.x < 0 || e.position.y < 0) {
      let i = {};
      if (ze(t.style) ? i = { ...t.style(t) } : t.style && (i = { ...t.style }), i.width = i.width ?? `${t.dimensions.width}px`, i.height = i.height ?? `${t.dimensions.height}px`, n > 0)
        if (Pe(i.width)) {
          const r = Number(i.width.replace("px", ""));
          i.width = `${r + n}px`;
        } else
          i.width += n;
      if (o > 0)
        if (Pe(i.height)) {
          const r = Number(i.height.replace("px", ""));
          i.height = `${r + o}px`;
        } else
          i.height += o;
      if (e.position.x < 0) {
        const r = Math.abs(e.position.x);
        if (t.position.x = t.position.x - r, Pe(i.width)) {
          const a = Number(i.width.replace("px", ""));
          i.width = `${a + r}px`;
        } else
          i.width += r;
        e.position.x = 0;
      }
      if (e.position.y < 0) {
        const r = Math.abs(e.position.y);
        if (t.position.y = t.position.y - r, Pe(i.height)) {
          const a = Number(i.height.replace("px", ""));
          i.height = `${a + r}px`;
        } else
          i.height += r;
        e.position.y = 0;
      }
      t.dimensions.width = Number(i.width.toString().replace("px", "")), t.dimensions.height = Number(i.height.toString().replace("px", "")), ze(t.style) ? t.style = (r) => {
        const a = t.style;
        return {
          ...a(r),
          ...i
        };
      } : t.style = {
        ...t.style,
        ...i
      };
    }
  }
}
function en(e, t) {
  e.filter((i) => i.type === "add" || i.type === "remove").forEach((i) => {
    if (i.type === "add")
      t.findIndex((a) => a.id === i.item.id) === -1 && t.push(i.item);
    else if (i.type === "remove") {
      const r = t.findIndex((a) => a.id === i.id);
      r !== -1 && t.splice(r, 1);
    }
  });
  const o = t.map((i) => i.id);
  return t.forEach((i) => {
    var a, s;
    const r = e.filter((l) => l.id === i.id);
    for (const l of r)
      switch (l.type) {
        case "select":
          i.selected = l.selected;
          break;
        case "position":
          if (et(i) && (typeof l.position < "u" && (i.position = l.position), typeof l.dragging < "u" && (i.dragging = l.dragging), i.expandParent && i.parentNode)) {
            const u = t[o.indexOf(i.parentNode)];
            u && et(u) && In(i, u);
          }
          break;
        case "dimensions":
          if (et(i)) {
            if (typeof l.dimensions < "u" && (i.dimensions = l.dimensions), typeof l.updateStyle < "u" && (i.style = {
              ...i.style || {},
              width: `${(a = l.dimensions) == null ? void 0 : a.width}px`,
              height: `${(s = l.dimensions) == null ? void 0 : s.height}px`
            }), typeof l.resizing < "u" && (i.resizing = l.resizing), i.expandParent && i.parentNode) {
              const u = t[o.indexOf(i.parentNode)];
              u && et(u) && (u.initialized ? In(i, u) : Ze(() => {
                In(i, u);
              }));
            }
            i.initialized || (i.initialized = !0);
          }
          break;
      }
  }), t;
}
function zd(e, t) {
  return en(e, t);
}
function Bd(e, t) {
  return en(e, t);
}
function Ie(e, t) {
  return {
    id: e,
    type: "select",
    selected: t
  };
}
function li(e) {
  return {
    item: e,
    type: "add"
  };
}
function Tn(e) {
  return {
    id: e,
    type: "remove"
  };
}
function Pn(e, t) {
  return e.reduce(
    (n, o) => {
      let i = t.includes(o.id);
      ue(o.selectable) && !o.selectable && (i = !1);
      const r = et(o) ? "changedNodes" : "changedEdges";
      return !o.selected && i ? n[r].push(Ie(o.id, !0)) : o.selected && !i && n[r].push(Ie(o.id, !1)), n;
    },
    { changedNodes: [], changedEdges: [] }
  );
}
function ed(e, t, n, o) {
  let i = !1;
  const r = Jc(e, t), a = (v) => {
    const b = v ?? n.value ?? [];
    e.hooks.updateNodeInternals.trigger(b);
  }, s = (v) => {
    if (v)
      return e.nodes && !n.value.length ? e.nodes.find((b) => b.id === v) : e.nodes[n.value.indexOf(v)];
  }, l = (v) => {
    if (v)
      return e.edges && !o.value.length ? e.edges.find((b) => b.id === v) : e.edges[o.value.indexOf(v)];
  }, u = (v, b, F) => {
    const T = [];
    v.forEach((V) => {
      var z, ne;
      const C = {
        id: V.id,
        type: "position",
        dragging: F,
        from: V.from
      };
      if (b && (C.position = V.position, V.parentNode)) {
        const re = s(V.parentNode);
        C.position = {
          x: C.position.x - (((z = re == null ? void 0 : re.computedPosition) == null ? void 0 : z.x) ?? 0),
          y: C.position.y - (((ne = re == null ? void 0 : re.computedPosition) == null ? void 0 : ne.y) ?? 0)
        };
      }
      T.push(C);
    }), T != null && T.length && e.hooks.nodesChange.trigger(T);
  }, c = (v) => {
    var V;
    if (!e.vueFlowRef)
      return;
    const b = e.vueFlowRef.querySelector(".vue-flow__transformationpane");
    if (!b)
      return;
    let F;
    if ((V = e.__experimentalFeatures) != null && V.nestedFlow) {
      let C = [b], z = b, ne;
      for (; !ne && z; )
        z = z.parentElement, ne = z == null ? void 0 : z.classList.contains("vue-flow__transformationpane"), ne && (C = [z, ...C]);
      C.forEach((re) => {
        const fe = window.getComputedStyle(re), { m22: _e } = new window.DOMMatrixReadOnly(fe.transform);
        F ? F *= _e : F = _e;
      });
    } else {
      const C = window.getComputedStyle(b), { m22: z } = new window.DOMMatrixReadOnly(C.transform);
      F = z;
    }
    const T = v.reduce((C, z) => {
      const ne = s(z.id);
      if (ne) {
        const re = nn(z.nodeElement);
        !!(re.width && re.height && (ne.dimensions.width !== re.width || ne.dimensions.height !== re.height || z.forceUpdate)) && (ne.handleBounds.source = Ro(".source", z.nodeElement, F), ne.handleBounds.target = Ro(".target", z.nodeElement, F), ne.dimensions = re, ne.initialized = !0, C.push({
          id: ne.id,
          type: "dimensions",
          dimensions: re
        }));
      }
      return C;
    }, []);
    e.fitViewOnInit && !i && (pe(() => r.value.initialized).toBe(!0).then(() => {
      r.value.fitView();
    }), i = !0), T.length && e.hooks.nodesChange.trigger(T);
  }, h = (v, b) => {
    const F = v.map((C) => C.id);
    let T, V = [];
    if (e.multiSelectionActive)
      T = F.map((C) => Ie(C, b));
    else {
      const C = Pn([...e.nodes, ...e.edges], F);
      T = C.changedNodes, V = C.changedEdges;
    }
    T.length && e.hooks.nodesChange.trigger(T), V.length && e.hooks.edgesChange.trigger(V);
  }, g = (v, b) => {
    const F = v.map((C) => C.id);
    let T = [], V;
    if (e.multiSelectionActive)
      V = F.map((C) => Ie(C, b));
    else {
      const C = Pn([...e.nodes, ...e.edges], F);
      T = C.changedNodes, V = C.changedEdges;
    }
    T.length && e.hooks.nodesChange.trigger(T), V.length && e.hooks.edgesChange.trigger(V);
  }, w = (v, b) => {
    const F = v.filter(xt).map((z) => z.id), T = v.filter($e).map((z) => z.id);
    let { changedNodes: V, changedEdges: C } = Pn([...e.nodes, ...e.edges], [...F, ...T]);
    e.multiSelectionActive && (V = F.map((z) => Ie(z, b)), C = T.map((z) => Ie(z, b))), V.length && e.hooks.nodesChange.trigger(V), C.length && e.hooks.edgesChange.trigger(C);
  }, f = (v) => {
    h(v, !0);
  }, d = (v) => {
    g(v, !0);
  }, _ = (v) => {
    w(v, !0);
  }, x = (v) => {
    if (!v.length)
      return h(v, !1);
    const F = v.map((T) => T.id).map((T) => Ie(T, !1));
    F.length && e.hooks.nodesChange.trigger(F);
  }, N = (v) => {
    if (!v.length)
      return g(v, !1);
    const F = v.map((T) => T.id).map((T) => Ie(T, !1));
    F.length && e.hooks.edgesChange.trigger(F);
  }, B = (v) => {
    if (!v || !v.length)
      return w([], !1);
    const { changedNodes: b, changedEdges: F } = v.reduce(
      (T, V) => {
        const C = Ie(V.id, !1);
        return xt(V) ? T.changedNodes.push(C) : T.changedEdges.push(C), T;
      },
      { changedNodes: [], changedEdges: [] }
    );
    b.length && e.hooks.nodesChange.trigger(b), F.length && e.hooks.edgesChange.trigger(F);
  }, y = (v) => {
    var b;
    (b = e.d3Zoom) == null || b.scaleExtent([v, e.maxZoom]), e.minZoom = v;
  }, $ = (v) => {
    var b;
    (b = e.d3Zoom) == null || b.scaleExtent([e.minZoom, v]), e.maxZoom = v;
  }, I = (v) => {
    var b;
    (b = e.d3Zoom) == null || b.translateExtent(v), e.translateExtent = v;
  }, m = (v) => {
    e.nodeExtent = v, a(n.value);
  }, G = (v) => {
    e.nodesDraggable = v, e.nodesConnectable = v, e.elementsSelectable = v;
  }, D = (v) => {
    const b = v instanceof Function ? v(e.nodes) : v;
    !e.initialized && !b.length || (e.nodes = Io(b, e.nodes, s, e.hooks.error.trigger));
  }, M = (v) => {
    const b = v instanceof Function ? v(e.edges) : v;
    if (!e.initialized && !b.length)
      return;
    const F = e.isValidConnection ? b.filter(
      (T) => e.isValidConnection(T, {
        edges: e.edges,
        sourceNode: s(T.source),
        targetNode: s(T.target)
      })
    ) : b;
    e.edges = F.reduce((T, V) => {
      const C = s(V.source), z = s(V.target), ne = !C || typeof C > "u", re = !z || typeof z > "u";
      if (ne && re ? e.hooks.error.trigger(new ve(he.EDGE_SOURCE_TARGET_MISSING, V.id, V.source, V.target)) : (ne && e.hooks.error.trigger(new ve(he.EDGE_SOURCE_MISSING, V.id, V.source)), re && e.hooks.error.trigger(new ve(he.EDGE_TARGET_MISSING, V.id, V.target))), ne || re)
        return T;
      const fe = l(V.id);
      return T.push({
        ...ao(V, Object.assign({}, fe, e.defaultEdgeOptions)),
        sourceNode: C,
        targetNode: z
      }), T;
    }, []);
  }, H = (v) => {
    const b = v instanceof Function ? v([...e.nodes, ...e.edges]) : v;
    !e.initialized && !b.length || (D(b.filter(xt)), M(b.filter($e)));
  }, j = (v) => {
    const b = v instanceof Function ? v(e.nodes) : v, T = Io(b, e.nodes, s, e.hooks.error.trigger).map(li);
    T.length && e.hooks.nodesChange.trigger(T);
  }, te = (v) => {
    const b = v instanceof Function ? v(e.edges) : v, T = (e.isValidConnection ? b.filter(
      (V) => e.isValidConnection(V, {
        edges: e.edges,
        sourceNode: s(V.source),
        targetNode: s(V.target)
      })
    ) : b).reduce((V, C) => {
      const z = ga(
        {
          ...C,
          ...e.defaultEdgeOptions
        },
        e.edges,
        e.hooks.error.trigger
      );
      if (z) {
        const ne = s(z.source), re = s(z.target), fe = !ne || typeof ne > "u", _e = !re || typeof re > "u";
        if (fe && _e ? e.hooks.error.trigger(new ve(he.EDGE_SOURCE_TARGET_MISSING, z.id, z.source, z.target)) : (fe && e.hooks.error.trigger(new ve(he.EDGE_SOURCE_MISSING, z.id, z.source)), _e && e.hooks.error.trigger(new ve(he.EDGE_TARGET_MISSING, z.id, z.target))), fe || _e)
          return V;
        V.push(
          li({
            ...z,
            sourceNode: ne,
            targetNode: re
          })
        );
      }
      return V;
    }, []);
    T.length && e.hooks.edgesChange.trigger(T);
  }, p = (v, b = !0) => {
    const F = v instanceof Function ? v(e.nodes) : v, T = [], V = [];
    F.forEach((C) => {
      const z = typeof C == "string" ? s(C) : C;
      if (!(ue(z.deletable) && !z.deletable) && (T.push(Tn(z.id)), b)) {
        const ne = rn([z], e.edges).filter((re) => ue(re.deletable) ? re.deletable : !0);
        V.push(...ne.map((re) => Tn(re.id)));
      }
    }), V.length && e.hooks.edgesChange.trigger(V), T.length && e.hooks.nodesChange.trigger(T);
  }, R = (v) => {
    const b = v instanceof Function ? v(e.edges) : v, F = [];
    b.forEach((T) => {
      const V = typeof T == "string" ? l(T) : T;
      ue(V.deletable) && !V.deletable || F.push(Tn(typeof T == "string" ? T : T.id));
    }), e.hooks.edgesChange.trigger(F);
  }, E = (v, b, F = !0) => va(v, b, e.edges, l, F, e.hooks.error.trigger), L = (v) => en(v, e.nodes), U = (v) => en(v, e.edges), W = (v, b, F, T = !1) => {
    T ? e.connectionClickStartHandle = v : e.connectionStartHandle = v, e.connectionEndHandle = null, e.connectionStatus = null, b && (e.connectionPosition = b);
  }, P = (v, b = null, F = null) => {
    e.connectionStartHandle && (e.connectionPosition = v, e.connectionEndHandle = b, e.connectionStatus = F);
  }, K = (v, b) => {
    e.connectionPosition = { x: NaN, y: NaN }, e.connectionStatus = null, b ? e.connectionClickStartHandle = null : e.connectionStartHandle = null;
  }, A = (v) => {
    const b = ca(v), F = b ? null : s(v.id);
    return !b && !F ? [null, null, b] : [b ? v : ko(F), F, b];
  }, J = (v, b = !0, F) => {
    const [T, V, C] = A(v);
    return T ? (F || e.nodes).filter((z) => {
      if (!C && (z.id === V.id || !z.computedPosition))
        return !1;
      const ne = ko(z), re = Ln(ne, T);
      return b && re > 0 || re >= Number(v.width) * Number(v.height);
    }) : [];
  }, Z = (v, b, F = !0) => {
    const [T] = A(v);
    if (!T)
      return !1;
    const V = Ln(T, b);
    return F && V > 0 || V >= Number(v.width) * Number(v.height);
  }, q = (v, b) => {
    const { viewport: F, dimensions: T, d3Zoom: V, d3Selection: C, translateExtent: z } = e;
    if (!V || !C || !v.x && !v.y)
      return;
    const ne = ht.translate(F.x + v.x, F.y + v.y).scale(F.zoom), re = [
      [0, 0],
      [T.width, T.height]
    ], fe = V.constrain()(ne, re, z);
    b == null || b(fe), V.transform(C, fe);
  }, O = (v) => {
    const b = v instanceof Function ? v(e) : v, F = [
      "modelValue",
      "nodes",
      "edges",
      "maxZoom",
      "minZoom",
      "translateExtent",
      "nodeExtent",
      "hooks",
      "defaultEdgeOptions"
    ];
    ue(b.defaultEdgeOptions) && (e.defaultEdgeOptions = b.defaultEdgeOptions);
    const T = b.modelValue || b.nodes || b.edges ? [] : void 0;
    T && (b.modelValue && T.push(...b.modelValue), b.nodes && T.push(...b.nodes), b.edges && T.push(...b.edges), H(T));
    const V = () => {
      ue(b.maxZoom) && $(b.maxZoom), ue(b.minZoom) && y(b.minZoom), ue(b.translateExtent) && I(b.translateExtent), ue(b.nodeExtent) && m(b.nodeExtent);
    };
    Object.keys(b).forEach((C) => {
      const z = b[C];
      !F.includes(C) && ue(z) && (e[C] = z);
    }), e.d3Zoom ? V() : pe(() => e.d3Zoom).not.toBeUndefined().then(V), e.initialized || (e.initialized = !0);
  };
  return {
    updateNodePositions: u,
    updateNodeDimensions: c,
    setElements: H,
    setNodes: D,
    setEdges: M,
    addNodes: j,
    addEdges: te,
    removeNodes: p,
    removeEdges: R,
    findNode: s,
    findEdge: l,
    updateEdge: E,
    applyEdgeChanges: U,
    applyNodeChanges: L,
    addSelectedElements: _,
    addSelectedNodes: f,
    addSelectedEdges: d,
    setMinZoom: y,
    setMaxZoom: $,
    setTranslateExtent: I,
    setNodeExtent: m,
    removeSelectedElements: B,
    removeSelectedNodes: x,
    removeSelectedEdges: N,
    startConnection: W,
    updateConnection: P,
    endConnection: K,
    setInteractive: G,
    setState: O,
    getIntersectingNodes: J,
    isNodeIntersecting: Z,
    panBy: q,
    fitView: async (v = { padding: 0.1 }) => {
      await pe(() => r.value.initialized).toBe(!0), r.value.fitView(v);
    },
    zoomIn: async (v) => {
      await pe(() => r.value.initialized).toBe(!0), r.value.zoomIn(v);
    },
    zoomOut: async (v) => {
      await pe(() => r.value.initialized).toBe(!0), r.value.zoomOut(v);
    },
    zoomTo: async (v, b) => {
      await pe(() => r.value.initialized).toBe(!0), r.value.zoomTo(v, b);
    },
    setTransform: async (v, b) => {
      await pe(() => r.value.initialized).toBe(!0), r.value.setTransform(v, b);
    },
    getTransform: () => r.value.getTransform(),
    setCenter: async (v, b, F) => {
      await pe(() => r.value.initialized).toBe(!0), r.value.setCenter(v, b, F);
    },
    fitBounds: async (v, b) => {
      await pe(() => r.value.initialized).toBe(!0), r.value.fitBounds(v, b);
    },
    project: (v) => r.value.project(v),
    toObject: () => JSON.parse(
      JSON.stringify({
        nodes: e.nodes.map((v) => {
          const {
            computedPosition: b,
            handleBounds: F,
            selected: T,
            dimensions: V,
            isParent: C,
            resizing: z,
            dragging: ne,
            initialized: re,
            ...fe
          } = v;
          return fe;
        }),
        edges: e.edges.map((v) => {
          const { selected: b, sourceNode: F, targetNode: T, ...V } = v;
          return V;
        }),
        position: [e.viewport.x, e.viewport.y],
        zoom: e.viewport.zoom
      })
    ),
    updateNodeInternals: a,
    $reset: () => {
      e.edges = [], e.nodes = [], O(or());
    },
    $destroy: () => {
    }
  };
}
class tt {
  constructor() {
    this.currentId = 0, this.flows = /* @__PURE__ */ new Map();
  }
  static getInstance() {
    return tt.instance || (tt.instance = new tt()), tt.instance;
  }
  set(t, n) {
    return this.flows.set(t, n);
  }
  get(t) {
    return this.flows.get(t);
  }
  remove(t) {
    return this.flows.delete(t);
  }
  create(t, n) {
    const o = or(n), i = Cr(o), r = ee(() => i.nodes.map((g) => g.id)), a = ee(() => i.edges.map((g) => g.id)), s = su(i, r, a), l = ed(i, s, r, a), u = {};
    Object.entries(i.hooks).forEach(([g, w]) => {
      const f = `on${g.charAt(0).toUpperCase() + g.slice(1)}`;
      u[f] = w.on;
    });
    const c = {};
    Object.entries(i.hooks).forEach(([g, w]) => {
      c[g] = w.trigger;
    }), l.setState(i);
    const h = {
      ...u,
      ...s,
      ...l,
      ...Mr(i),
      emits: c,
      id: t,
      vueFlowVersion: "1.19.2",
      $destroy: () => {
        this.remove(t);
      }
    };
    return this.set(t, h), h;
  }
  getId() {
    return `vue-flow-${this.currentId++}`;
  }
}
const de = (e) => {
  const t = tt.getInstance(), n = ci(), o = e == null ? void 0 : e.id, i = (n == null ? void 0 : n.vueFlowId) || o;
  let r, a = !1;
  if (n) {
    const s = He(To, null);
    typeof s < "u" && s !== null && (r = s);
  }
  if (r || i && (r = t.get(i)), !r || r && o && o !== r.id) {
    const s = o ?? t.getId();
    r = t.create(s, e), n && (a = !0);
  } else
    e && r.setState(e);
  return n && (st(To, r), n.vueFlowId = r.id, a && Mt(() => {
    if (r) {
      const s = t.get(r.id);
      s ? s.$destroy() : wt(`No store instance found for id ${r.id} in storage.`);
    }
  })), r;
};
function td(e, t, n) {
  const o = $r();
  return o.run(() => {
    [
      () => {
        o.run(() => {
          let f, d, _ = !!(n.nodes.value.length || n.edges.value.length);
          f = Je([e.modelValue, () => {
            var x, N;
            return (N = (x = e.modelValue) == null ? void 0 : x.value) == null ? void 0 : N.length;
          }], ([x]) => {
            x && Array.isArray(x) && (d == null || d.pause(), n.setElements(x), !d && !_ && x.length ? _ = !0 : d == null || d.resume());
          }), d = Je(
            [n.nodes, n.edges, () => n.edges.value.length, () => n.nodes.value.length],
            ([x, N]) => {
              var B;
              (B = e.modelValue) != null && B.value && Array.isArray(e.modelValue.value) && (f == null || f.pause(), e.modelValue.value = [...x, ...N], Ze(() => {
                f == null || f.resume();
              }));
            },
            { immediate: _ }
          ), Bt(() => {
            f == null || f.stop(), d == null || d.stop();
          });
        });
      },
      () => {
        o.run(() => {
          let f, d, _ = !!n.nodes.value.length;
          f = Je([e.nodes, () => {
            var x, N;
            return (N = (x = e.nodes) == null ? void 0 : x.value) == null ? void 0 : N.length;
          }], ([x]) => {
            x && Array.isArray(x) && (d == null || d.pause(), n.setNodes(x), !d && !_ && x.length ? _ = !0 : d == null || d.resume());
          }), d = Je(
            [n.nodes, () => n.nodes.value.length],
            ([x]) => {
              var N;
              (N = e.nodes) != null && N.value && Array.isArray(e.nodes.value) && (f == null || f.pause(), e.nodes.value = [...x], Ze(() => {
                f == null || f.resume();
              }));
            },
            { immediate: _ }
          ), Bt(() => {
            f == null || f.stop(), d == null || d.stop();
          });
        });
      },
      () => {
        o.run(() => {
          let f, d, _ = !!n.edges.value.length;
          f = Je([e.edges, () => {
            var x, N;
            return (N = (x = e.edges) == null ? void 0 : x.value) == null ? void 0 : N.length;
          }], ([x]) => {
            x && Array.isArray(x) && (d == null || d.pause(), n.setEdges(x), !d && !_ && x.length ? _ = !0 : d == null || d.resume());
          }), d = Je(
            [n.edges, () => n.edges.value.length],
            ([x]) => {
              var N;
              (N = e.edges) != null && N.value && Array.isArray(e.edges.value) && (f == null || f.pause(), e.edges.value = [...x], Ze(() => {
                f == null || f.resume();
              }));
            },
            { immediate: _ }
          ), Bt(() => {
            f == null || f.stop(), d == null || d.stop();
          });
        });
      },
      () => {
        o.run(() => {
          ce(
            () => t.minZoom,
            () => {
              t.minZoom && ue(t.minZoom) && n.setMinZoom(t.minZoom);
            }
          );
        });
      },
      () => {
        o.run(() => {
          ce(
            () => t.maxZoom,
            () => {
              t.maxZoom && ue(t.maxZoom) && n.setMaxZoom(t.maxZoom);
            }
          );
        });
      },
      () => {
        o.run(() => {
          ce(
            () => t.translateExtent,
            () => {
              t.translateExtent && ue(t.translateExtent) && n.setTranslateExtent(t.translateExtent);
            }
          );
        });
      },
      () => {
        o.run(() => {
          ce(
            () => t.nodeExtent,
            () => {
              t.nodeExtent && ue(t.nodeExtent) && n.setNodeExtent(t.nodeExtent);
            }
          );
        });
      },
      () => {
        o.run(() => {
          ce(
            () => t.applyDefault,
            () => {
              ue(t.applyDefault) && (n.applyDefault.value = t.applyDefault);
            }
          ), ce(
            n.applyDefault,
            (f, d, _) => {
              n.applyDefault.value ? (n.onNodesChange(n.applyNodeChanges), n.onEdgesChange(n.applyEdgeChanges)) : (n.hooks.value.nodesChange.off(n.applyNodeChanges), n.hooks.value.edgesChange.off(n.applyEdgeChanges)), _(() => {
                n.hooks.value.nodesChange.off(n.applyNodeChanges), n.hooks.value.edgesChange.off(n.applyEdgeChanges);
              });
            },
            { immediate: !0 }
          );
        });
      },
      () => {
        o.run(() => {
          const f = async (d) => {
            let _ = d;
            ze(t.autoConnect) && (_ = await t.autoConnect(d)), _ !== !1 && n.addEdges([_]);
          };
          ce(
            () => t.autoConnect,
            () => {
              ue(t.autoConnect) && (n.autoConnect.value = t.autoConnect);
            }
          ), ce(
            n.autoConnect,
            (d, _, x) => {
              d ? n.onConnect(f) : n.hooks.value.connect.off(f), x(() => {
                n.hooks.value.connect.off(f);
              });
            },
            { immediate: !0 }
          );
        });
      },
      () => {
        const f = [
          "id",
          "modelValue",
          "translateExtent",
          "nodeExtent",
          "edges",
          "nodes",
          "maxZoom",
          "minZoom",
          "applyDefault",
          "autoConnect"
        ];
        Object.keys(t).forEach((d) => {
          if (!f.includes(d)) {
            const _ = S(t, d), x = n[d];
            o.run(() => {
              ce(
                _,
                (N) => {
                  ue(N) && (x.value = N);
                },
                { flush: "pre" }
              );
            });
          }
        });
      }
    ].forEach((f) => f());
  }), () => o.stop();
}
function ui(e, t) {
  return {
    x: e.clientX - t.left,
    y: e.clientY - t.top
  };
}
const nd = {
  name: "Pane",
  compatConfig: { MODE: 3 }
}, od = /* @__PURE__ */ ge({
  ...nd,
  props: {
    isSelecting: { type: Boolean }
  },
  setup(e) {
    const {
      id: t,
      vueFlowRef: n,
      getNodes: o,
      getEdges: i,
      viewport: r,
      emits: a,
      userSelectionActive: s,
      removeSelectedElements: l,
      panOnDrag: u,
      userSelectionRect: c,
      elementsSelectable: h,
      nodesSelectionActive: g,
      addSelectedElements: w,
      getSelectedEdges: f,
      getSelectedNodes: d,
      removeNodes: _,
      removeEdges: x,
      selectionMode: N,
      deleteKeyCode: B,
      multiSelectionKeyCode: y,
      multiSelectionActive: $
    } = de(), I = oe(null), m = oe(0), G = oe(0), D = oe(), M = ee(() => h.value && (e.isSelecting || s.value));
    _t(B, (P) => {
      if (!P)
        return;
      const K = o.value.reduce((A, J) => ((!J.selected && J.parentNode && A.find((Z) => Z.id === J.parentNode) || J.selected) && A.push(J), A), []);
      (K || f.value) && (f.value.length > 0 && x(f.value), K.length > 0 && _(K), g.value = !1, l());
    }), _t(y, (P) => {
      $.value = P;
    });
    function H() {
      s.value = !1, c.value = null, m.value = 0, G.value = 0;
    }
    function j(P) {
      P.target !== I.value || M.value || (a.paneClick(P), l(), g.value = !1);
    }
    function te(P) {
      var K;
      if (P.target === I.value) {
        if (Array.isArray(u.value) && ((K = u.value) != null && K.includes(2))) {
          P.preventDefault();
          return;
        }
        a.paneContextMenu(P);
      }
    }
    function p(P) {
      P.target === I.value && a.paneScroll(P);
    }
    function R(P) {
      if (D.value = n.value.getBoundingClientRect(), !M.value || !h || !e.isSelecting || P.button !== 0 || P.target !== I.value || !D.value)
        return;
      const { x: K, y: A } = ui(P, D.value);
      l(), c.value = {
        width: 0,
        height: 0,
        startX: K,
        startY: A,
        x: K,
        y: A
      }, s.value = !0, a.selectionStart(P);
    }
    function E(P) {
      if (!e.isSelecting || !D.value || !c.value)
        return;
      if (!M.value)
        return a.paneMouseMove(P);
      s.value || (s.value = !0), g.value && (g.value = !1);
      const K = ui(P, D.value), A = c.value.startX ?? 0, J = c.value.startY ?? 0, Z = {
        ...c.value,
        x: K.x < A ? K.x : A,
        y: K.y < J ? K.y : J,
        width: Math.abs(K.x - A),
        height: Math.abs(K.y - J)
      }, q = Ei(
        o.value,
        c.value,
        r.value,
        N.value === uo.Partial
      ), O = rn(q, i.value);
      m.value = q.length, G.value = O.length, c.value = Z, w([...q, ...O]);
    }
    function L(P) {
      M.value && P.button === 0 && (!s.value && c.value && P.target === I.value && j(P), g.value = m.value > 0, H(), a.selectionEnd(P));
    }
    function U(P) {
      var K;
      if (!M.value)
        return a.paneMouseLeave(P);
      s.value && (g.value = m.value > 0, (K = a.selectionEnd) == null || K.call(a, P)), H();
    }
    function W(P) {
      M.value || a.paneMouseEnter(P);
    }
    return (P, K) => (ie(), ae("div", {
      ref_key: "container",
      ref: I,
      key: `pane-${k(t)}`,
      class: We(["vue-flow__pane vue-flow__container", { selection: e.isSelecting }]),
      onClick: j,
      onContextmenu: te,
      onWheelPassive: p,
      onMouseenter: W,
      onMousedown: R,
      onMousemove: E,
      onMouseup: L,
      onMouseleave: U
    }, [
      ye(P.$slots, "default"),
      k(s) && k(c) ? (ie(), Ae(ou, { key: 0 })) : Ee("", !0),
      k(g) && k(d).length ? (ie(), Ae(tu, { key: 1 })) : Ee("", !0)
    ], 34));
  }
}), id = { class: "vue-flow__nodes vue-flow__container" }, rd = {
  name: "Nodes",
  compatConfig: { MODE: 3 }
}, ad = /* @__PURE__ */ ge({
  ...rd,
  setup(e) {
    const t = He(an), n = de(), o = S(n, "nodesDraggable"), i = S(n, "nodesFocusable"), r = S(n, "elementsSelectable"), a = S(n, "nodesConnectable"), s = S(n, "getNodes"), l = S(n, "getNodesInitialized"), u = S(n, "getNodeTypes"), c = S(n, "updateNodeDimensions"), h = S(n, "emits");
    let g = oe();
    pe(() => s.value.length > 0 && l.value.length === s.value.length).toBe(!0).then(() => {
      Ze(() => {
        h.value.nodesInitialized(l.value);
      });
    }), Ve(() => {
      g.value = new ResizeObserver((N) => {
        const B = N.map((y) => ({
          id: y.target.getAttribute("data-id"),
          nodeElement: y.target,
          forceUpdate: !0
        }));
        c.value(B);
      });
    }), di(() => {
      var N;
      return (N = g.value) == null ? void 0 : N.disconnect();
    });
    function w(N) {
      return typeof N > "u" ? o.value : N;
    }
    function f(N) {
      return typeof N > "u" ? r.value : N;
    }
    function d(N) {
      return typeof N > "u" ? a.value : N;
    }
    function _(N) {
      return typeof N > "u" ? i.value : N;
    }
    function x(N, B) {
      const y = N || "default";
      let $ = B ?? u.value[y];
      const I = tn();
      if (typeof $ == "string" && I) {
        const G = Object.keys(I.appContext.components);
        G && G.includes(y) && ($ = gi(y, !1));
      }
      if (typeof $ != "string")
        return $;
      const m = t == null ? void 0 : t[`node-${y}`];
      return m || (h.value.error(new ve(he.NODE_TYPE_MISSING, $)), !1);
    }
    return (N, B) => (ie(), ae("div", id, [
      k(g) ? (ie(!0), ae(Ce, { key: 0 }, ut(k(s), (y) => (ie(), Ae(k($l), {
        id: y.id,
        key: y.id,
        "resize-observer": k(g),
        type: x(y.type, y.template),
        name: y.type || "default",
        draggable: w(y.draggable),
        selectable: f(y.selectable),
        connectable: d(y.connectable),
        focusable: _(y.focusable),
        node: y
      }, null, 8, ["id", "resize-observer", "type", "name", "draggable", "selectable", "connectable", "focusable", "node"]))), 128)) : Ee("", !0)
    ]));
  }
}), sd = ["id", "markerWidth", "markerHeight", "markerUnits", "orient"], ld = ["stroke", "stroke-width", "fill"], ud = ["stroke", "stroke-width"], cd = {
  name: "MarkerType",
  compatConfig: { MODE: 3 }
}, dd = /* @__PURE__ */ ge({
  ...cd,
  props: {
    id: null,
    type: null,
    color: { default: "none" },
    width: { default: 12.5 },
    height: { default: 12.5 },
    markerUnits: { default: "strokeWidth" },
    orient: { default: "auto-start-reverse" },
    strokeWidth: { default: 1 }
  },
  setup(e) {
    return (t, n) => (ie(), ae("marker", {
      id: e.id,
      class: "vue-flow__arrowhead",
      viewBox: "-10 -10 20 20",
      refX: "0",
      refY: "0",
      markerWidth: `${e.width}`,
      markerHeight: `${e.height}`,
      markerUnits: e.markerUnits,
      orient: e.orient
    }, [
      e.type === k(Fn).ArrowClosed ? (ie(), ae("polyline", {
        key: 0,
        stroke: e.color,
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": e.strokeWidth,
        fill: e.color,
        points: "-5,-4 0,0 -5,4 -5,-4"
      }, null, 8, ld)) : Ee("", !0),
      e.type === k(Fn).Arrow ? (ie(), ae("polyline", {
        key: 1,
        stroke: e.color,
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": e.strokeWidth,
        fill: "none",
        points: "-5,-4 0,0 -5,4"
      }, null, 8, ud)) : Ee("", !0)
    ], 8, sd));
  }
}), fd = {
  name: "MarkerDefinitions",
  compatConfig: { MODE: 3 }
}, hd = /* @__PURE__ */ ge({
  ...fd,
  setup(e) {
    const t = de(), n = S(t, "id"), o = S(t, "edges"), i = S(t, "connectionLineOptions"), r = S(t, "defaultMarkerColor"), a = ee(() => {
      const s = [], l = [], u = (c) => {
        if (c) {
          const h = Xe(c, n.value);
          s.includes(h) || (typeof c == "object" ? l.push({ ...c, id: h, color: c.color || r.value }) : l.push({ id: h, color: r.value, type: c }), s.push(h));
        }
      };
      return [i.value.markerEnd, i.value.markerStart].forEach(u), o.value.reduce((c, h) => ([h.markerStart, h.markerEnd].forEach(u), c.sort((g, w) => g.id.localeCompare(w.id))), l), l;
    });
    return (s, l) => (ie(), ae("defs", null, [
      (ie(!0), ae(Ce, null, ut(k(a), (u) => (ie(), Ae(dd, {
        id: u.id,
        key: u.id,
        type: u.type,
        color: u.color,
        width: u.width,
        height: u.height,
        markerUnits: u.markerUnits,
        "stroke-width": u.strokeWidth,
        orient: u.orient
      }, null, 8, ["id", "type", "color", "width", "height", "markerUnits", "stroke-width", "orient"]))), 128))
    ]));
  }
}), gd = {
  key: 0,
  class: "vue-flow__edges vue-flow__connectionline vue-flow__container"
}, vd = {
  name: "Edges",
  compatConfig: { MODE: 3 }
}, md = /* @__PURE__ */ ge({
  ...vd,
  setup(e) {
    const t = He(an), n = de(), o = S(n, "connectionStartHandle"), i = S(n, "nodesConnectable"), r = S(n, "edgesUpdatable"), a = S(n, "edgesFocusable"), s = S(n, "elementsSelectable"), l = S(n, "getSelectedNodes"), u = S(n, "findNode"), c = S(n, "getEdges"), h = S(n, "getNodesInitialized"), g = S(n, "getEdgeTypes"), w = S(n, "elevateEdgesOnSelect"), f = S(n, "dimensions"), d = S(n, "emits"), _ = wn(
      () => {
        var m;
        return (m = o.value) == null ? void 0 : m.nodeId;
      },
      () => {
        var m;
        return (m = o.value) != null && m.nodeId ? u.value(o.value.nodeId) : !1;
      }
    ), x = wn(
      () => {
        var m;
        return (m = o.value) == null ? void 0 : m.nodeId;
      },
      () => {
        var m, G;
        return !!(_.value && (typeof _.value.connectable > "u" ? i.value : _.value.connectable) && ((m = o.value) != null && m.nodeId) && ((G = o.value) != null && G.type));
      }
    ), N = wn(
      [
        () => c.value.map((m) => m.zIndex),
        () => w.value ? [l.value.length] : [0],
        () => w.value ? h.value.map((m) => m.computedPosition.z) : []
      ],
      () => _a(c.value, u.value, w.value)
    );
    function B(m) {
      return typeof m > "u" ? s.value : m;
    }
    function y(m) {
      return typeof m > "u" ? r.value : m;
    }
    function $(m) {
      return typeof m > "u" ? a.value : m;
    }
    function I(m, G) {
      const D = m || "default";
      let M = G ?? g.value[D];
      const H = tn();
      if (typeof M == "string" && H) {
        const te = Object.keys(H.appContext.components);
        te && te.includes(D) && (M = gi(D, !1));
      }
      if (M && typeof M != "string")
        return M;
      const j = t == null ? void 0 : t[`edge-${D}`];
      return j || (d.value.error(new ve(he.EDGE_TYPE_MISSING, M)), !1);
    }
    return (m, G) => k(f).width && k(f).height ? (ie(), ae(Ce, { key: 0 }, [
      (ie(!0), ae(Ce, null, ut(k(N), (D) => (ie(), ae("svg", {
        key: D.level,
        class: "vue-flow__edges vue-flow__container",
        style: Le(`z-index: ${D.level}`)
      }, [
        D.isMaxLevel ? (ie(), Ae(hd, { key: 0 })) : Ee("", !0),
        lt("g", null, [
          (ie(!0), ae(Ce, null, ut(D.edges, (M) => (ie(), Ae(k(Ul), {
            id: M.id,
            key: M.id,
            edge: M,
            type: I(M.type, M.template),
            name: M.type || "default",
            selectable: B(M.selectable),
            updatable: y(M.updatable),
            focusable: $(M.focusable)
          }, null, 8, ["id", "edge", "type", "name", "selectable", "updatable", "focusable"]))), 128))
        ])
      ], 4))), 128)),
      k(x) && k(_) ? (ie(), ae("svg", gd, [
        qe(Ql, { "source-node": k(_) }, null, 8, ["source-node"])
      ])) : Ee("", !0)
    ], 64)) : Ee("", !0);
  }
}), pd = /* @__PURE__ */ lt("div", { class: "vue-flow__edge-labels" }, null, -1), yd = {
  name: "Transform",
  compatConfig: { MODE: 3 }
}, xd = /* @__PURE__ */ ge({
  ...yd,
  setup(e) {
    const { id: t, viewport: n, emits: o, d3Zoom: i, d3Selection: r, dimensions: a, ...s } = de(), l = oe(!to);
    return pe(() => i.value && r.value && a.value.width > 0 && a.value.height > 0).toBeTruthy().then(() => {
      o.paneReady({
        id: t,
        viewport: n,
        emits: o,
        d3Zoom: i,
        d3Selection: r,
        dimensions: a,
        ...s
      }), setTimeout(() => {
        l.value = !0;
      }, 0);
    }), (u, c) => (ie(), ae("div", {
      key: `transform-${k(t)}`,
      class: "vue-flow__transformationpane vue-flow__container",
      style: Le({
        transform: `translate(${k(n).x}px,${k(n).y}px) scale(${k(n).zoom})`,
        opacity: k(l) ? void 0 : 0
      })
    }, [
      qe(md),
      pd,
      qe(ad),
      ye(u.$slots, "default")
    ], 4));
  }
}), _d = {
  name: "Viewport",
  compatConfig: { MODE: 3 }
}, wd = /* @__PURE__ */ ge({
  ..._d,
  setup(e) {
    const t = de(), n = S(t, "id"), o = S(t, "minZoom"), i = S(t, "maxZoom"), r = S(t, "defaultViewport"), a = S(t, "translateExtent"), s = S(t, "dimensions"), l = S(t, "zoomActivationKeyCode"), u = S(t, "selectionKeyCode"), c = S(t, "panActivationKeyCode"), h = S(t, "panOnScroll"), g = S(t, "panOnScrollMode"), w = S(t, "panOnScrollSpeed"), f = S(t, "panOnDrag"), d = S(t, "zoomOnDoubleClick"), _ = S(t, "zoomOnPinch"), x = S(t, "zoomOnScroll"), N = S(t, "preventScrolling"), B = S(t, "noWheelClassName"), y = S(t, "noPanClassName"), $ = S(t, "setState"), I = S(t, "emits"), m = S(t, "connectionStartHandle"), G = S(t, "userSelectionActive"), D = S(t, "paneDragging"), M = oe();
    let H = oe(!1), j = oe(!1), te = oe(!1), p = oe(0);
    const R = _t(c.value), E = ee(() => !H.value && f.value && R.value), L = ee(
      () => u.value !== !0 && H.value || u.value === !0 && E.value !== !0
    );
    let U = oe({
      x: 0,
      y: 0,
      zoom: 0
    });
    Ve(() => {
      ea(M, A);
      const Z = io();
      oo(Z, "resize", A);
    }), Ve(() => {
      const Z = M.value, q = Z.getBoundingClientRect(), O = jc().scaleExtent([o.value, i.value]).translateExtent(a.value), Y = we(Z).call(O), v = Y.on("wheel.zoom"), b = ht.translate(r.value.x ?? 0, r.value.y ?? 0).scale(ct(r.value.zoom ?? 1, o.value, i.value)), F = [
        [0, 0],
        [q.width, q.height]
      ], T = O.constrain()(b, F, a.value);
      O.transform(Y, T), $.value({
        d3Zoom: O,
        d3Selection: Y,
        d3ZoomHandler: v,
        viewport: { x: T.x, y: T.y, zoom: T.k },
        viewportRef: Z
      }), _t(u.value, (C) => {
        H.value = C;
      });
      const V = _t(l.value);
      zn(() => {
        H.value && G.value && !j.value ? O.on("zoom", null) : !H.value && !G.value && O.on("zoom", (C) => {
          $.value({ viewport: { x: C.transform.x, y: C.transform.y, zoom: C.transform.k } });
          const z = K(C.transform);
          te.value = W(f.value, p.value ?? 0), I.value.viewportChange(z), I.value.move({ event: C, flowTransform: z });
        });
      }), O.on("start", (C) => {
        var ne;
        if (!C.sourceEvent)
          return null;
        p.value = C.sourceEvent.button, j.value = !0;
        const z = K(C.transform);
        ((ne = C.sourceEvent) == null ? void 0 : ne.type) === "mousedown" && $.value({ paneDragging: !0 }), U.value = z, I.value.viewportChangeStart(z), I.value.moveStart({ event: C, flowTransform: z });
      }), O.on("end", (C) => {
        if (!C.sourceEvent)
          return null;
        if (j.value = !1, $.value({ paneDragging: !1 }), W(f.value, p.value ?? 0) && !te.value && I.value.paneContextMenu(C.sourceEvent), te.value = !1, P(U.value, C.transform)) {
          const z = K(C.transform);
          U.value = z, I.value.viewportChangeEnd(z), I.value.moveEnd({ event: C, flowTransform: z });
        }
      }), zn(() => {
        h.value && !V.value && !G.value ? Y.on(
          "wheel.zoom",
          (C) => {
            if (J(C, B.value))
              return !1;
            C.preventDefault(), C.stopImmediatePropagation();
            const z = Y.property("__zoom").k || 1;
            if (C.ctrlKey && _.value) {
              const _e = Ne(C), pr = -C.deltaY * (C.deltaMode === 1 ? 0.05 : C.deltaMode ? 1 : 2e-3) * 10, yr = z * 2 ** pr;
              O.scaleTo(Y, yr, _e);
              return;
            }
            const ne = C.deltaMode === 1 ? 20 : 1, re = g.value === Xt.Vertical ? 0 : C.deltaX * ne, fe = g.value === Xt.Horizontal ? 0 : C.deltaY * ne;
            O.translateBy(Y, -(re / z) * w.value, -(fe / z) * w.value);
          },
          { passive: !1 }
        ) : typeof v < "u" && Y.on(
          "wheel.zoom",
          function(C, z) {
            if (!N.value || J(C, B.value))
              return null;
            C.preventDefault(), v.call(this, C, z);
          },
          { passive: !1 }
        );
      }), O.filter((C) => {
        var fe, _e;
        const z = V.value || x.value, ne = _.value && C.ctrlKey;
        if (C.button === 1 && C.type === "mousedown" && ((fe = C.target) != null && fe.closest(".vue-flow__node") || (_e = C.target) != null && _e.closest(".vue-flow__edge")))
          return !0;
        if (!f.value && !z && !h.value && !d.value && !_.value || G.value || !d.value && C.type === "dblclick" || J(C, B.value) && C.type === "wheel" || J(C, y.value) && C.type !== "wheel" || !_.value && C.ctrlKey && C.type === "wheel" || !z && !h.value && !ne && C.type === "wheel" || !f.value && (C.type === "mousedown" || C.type === "touchstart") || Array.isArray(f.value) && !f.value.includes(C.button) && (C.type === "mousedown" || C.type === "touchstart"))
          return !1;
        const re = Array.isArray(f.value) && f.value.includes(C.button) || !C.button || C.button <= 1;
        return (!C.ctrlKey || C.type === "wheel") && re;
      });
    });
    function W(Z, q) {
      return q === 2 && Array.isArray(Z) && Z.includes(2);
    }
    function P(Z, q) {
      return Z.x !== q.x && !isNaN(q.x) || Z.y !== q.y && !isNaN(q.y) || Z.zoom !== q.k && !isNaN(q.k);
    }
    function K(Z) {
      return {
        x: Z.x,
        y: Z.y,
        zoom: Z.k
      };
    }
    function A() {
      if (!M.value)
        return;
      const { width: Z, height: q } = nn(M.value);
      (Z === 0 || q === 0) && I.value.error(new ve(he.MISSING_VIEWPORT_DIMENSIONS)), s.value.width = Z || 500, s.value.height = q || 500;
    }
    function J(Z, q) {
      return Z.target.closest(`.${q}`);
    }
    return (Z, q) => (ie(), ae(Ce, null, [
      (ie(), ae("div", {
        ref_key: "viewportEl",
        ref: M,
        key: `viewport-${k(n)}`,
        class: "vue-flow__viewport vue-flow__container"
      }, [
        qe(od, {
          "is-selecting": k(L),
          class: We({ connecting: !!k(m), dragging: k(D), draggable: !!k(f) })
        }, {
          default: Ge(() => [
            qe(xd, null, {
              default: Ge(() => [
                ye(Z.$slots, "zoom-pane")
              ]),
              _: 3
            })
          ]),
          _: 3
        }, 8, ["is-selecting", "class"])
      ])),
      ye(Z.$slots, "default")
    ], 64));
  }
}), bd = ["id"], Ed = ["id"], Sd = ["id"], Nd = {
  name: "A11yDescriptions",
  compatConfig: { MODE: 3 }
}, Cd = /* @__PURE__ */ ge({
  ...Nd,
  setup(e) {
    const { id: t, disableKeyboardA11y: n, ariaLiveMessage: o } = de(), i = {
      position: "absolute",
      width: 1,
      height: 1,
      margin: -1,
      border: 0,
      padding: 0,
      overflow: "hidden",
      clip: "rect(0px, 0px, 0px, 0px)",
      clipPath: "inset(100%)"
    };
    return (r, a) => (ie(), ae(Ce, null, [
      lt("div", {
        id: `${k(Wi)}-${k(t)}`,
        style: { display: "none" }
      }, " Press enter or space to select a node. " + Bn(k(n) ? "" : "You can then use the arrow keys to move the node around.") + " You can then use the arrow keys to move the node around, press delete to remove it and press escape to cancel. ", 9, bd),
      lt("div", {
        id: `${k(qi)}-${k(t)}`,
        style: { display: "none" }
      }, " Press enter or space to select an edge. You can then press delete to remove it or press escape to cancel. ", 8, Ed),
      k(n) ? Ee("", !0) : (ie(), ae("div", {
        key: 0,
        id: `${k(Sl)}-${k(t)}`,
        "aria-live": "assertive",
        "aria-atomic": "true",
        style: i
      }, Bn(k(o)), 9, Sd))
    ], 64));
  }
}), Md = {
  name: "VueFlow",
  compatConfig: { MODE: 3 }
}, Rd = /* @__PURE__ */ ge({
  ...Md,
  props: {
    id: null,
    modelValue: null,
    nodes: null,
    edges: null,
    edgeTypes: null,
    nodeTypes: null,
    connectionMode: null,
    connectionLineType: null,
    connectionLineStyle: { default: void 0 },
    connectionLineOptions: { default: void 0 },
    connectionRadius: null,
    isValidConnection: { type: [Function, null], default: void 0 },
    deleteKeyCode: null,
    selectionKeyCode: null,
    multiSelectionKeyCode: null,
    zoomActivationKeyCode: null,
    panActivationKeyCode: null,
    snapToGrid: { type: Boolean, default: void 0 },
    snapGrid: null,
    onlyRenderVisibleElements: { type: Boolean, default: void 0 },
    edgesUpdatable: { type: [Boolean, String], default: void 0 },
    nodesDraggable: { type: Boolean, default: void 0 },
    nodesConnectable: { type: Boolean, default: void 0 },
    elementsSelectable: { type: Boolean, default: void 0 },
    selectNodesOnDrag: { type: Boolean, default: void 0 },
    panOnDrag: { type: [Boolean, Array], default: void 0 },
    minZoom: null,
    maxZoom: null,
    defaultViewport: null,
    translateExtent: null,
    nodeExtent: null,
    defaultMarkerColor: null,
    zoomOnScroll: { type: Boolean, default: void 0 },
    zoomOnPinch: { type: Boolean, default: void 0 },
    panOnScroll: { type: Boolean, default: void 0 },
    panOnScrollSpeed: null,
    panOnScrollMode: null,
    zoomOnDoubleClick: { type: Boolean, default: void 0 },
    preventScrolling: { type: Boolean, default: void 0 },
    selectionMode: null,
    edgeUpdaterRadius: null,
    fitViewOnInit: { type: Boolean, default: void 0 },
    connectOnClick: { type: Boolean, default: void 0 },
    applyDefault: { type: Boolean, default: void 0 },
    autoConnect: { type: [Boolean, Function], default: void 0 },
    noDragClassName: null,
    noWheelClassName: null,
    noPanClassName: null,
    defaultEdgeOptions: null,
    elevateEdgesOnSelect: { type: Boolean, default: void 0 },
    elevateNodesOnSelect: { type: Boolean, default: void 0 },
    disableKeyboardA11y: { type: Boolean, default: void 0 },
    edgesFocusable: { type: Boolean, default: void 0 },
    nodesFocusable: { type: Boolean, default: void 0 },
    autoPanOnConnect: { type: Boolean, default: void 0 },
    autoPanOnNodeDrag: { type: Boolean, default: void 0 },
    __experimentalFeatures: null
  },
  emits: ["nodesChange", "edgesChange", "nodeDoubleClick", "nodeClick", "nodeMouseEnter", "nodeMouseMove", "nodeMouseLeave", "nodeContextMenu", "nodeDragStart", "nodeDrag", "nodeDragStop", "nodesInitialized", "miniMapNodeClick", "miniMapNodeDoubleClick", "miniMapNodeMouseEnter", "miniMapNodeMouseMove", "miniMapNodeMouseLeave", "connect", "connectStart", "connectEnd", "clickConnectStart", "clickConnectEnd", "moveStart", "move", "moveEnd", "selectionDragStart", "selectionDrag", "selectionDragStop", "selectionContextMenu", "selectionStart", "selectionEnd", "viewportChangeStart", "viewportChange", "viewportChangeEnd", "paneReady", "paneScroll", "paneClick", "paneContextMenu", "paneMouseEnter", "paneMouseMove", "paneMouseLeave", "edgeContextMenu", "edgeMouseEnter", "edgeMouseMove", "edgeMouseLeave", "edgeDoubleClick", "edgeClick", "edgeUpdateStart", "edgeUpdate", "edgeUpdateEnd", "updateNodeInternals", "error", "update:modelValue", "update:nodes", "update:edges"],
  setup(e, { expose: t, emit: n }) {
    const o = e, i = yt(o, "modelValue", n), r = yt(o, "nodes", n), a = yt(o, "edges", n), { vueFlowRef: s, hooks: l, getNodeTypes: u, getEdgeTypes: c, ...h } = de(o), g = td({ modelValue: i, nodes: r, edges: a }, o, {
      vueFlowRef: s,
      hooks: l,
      getNodeTypes: u,
      getEdgeTypes: c,
      ...h
    });
    la(n, l);
    const w = oe();
    return st(an, kr()), Or(() => {
      g();
    }), Ve(() => {
      s.value = w.value;
    }), t({
      vueFlowRef: s,
      hooks: l,
      getNodeTypes: u,
      getEdgeTypes: c,
      ...h
    }), (f, d) => (ie(), ae("div", {
      ref_key: "el",
      ref: w,
      class: "vue-flow"
    }, [
      qe(wd, null, {
        nodes: Ge(() => [
          (ie(!0), ae(Ce, null, ut(Object.keys(k(u)), (_) => ye(f.$slots, `node-${_}`)), 256))
        ]),
        edges: Ge(() => [
          (ie(!0), ae(Ce, null, ut(Object.keys(k(c)), (_) => ye(f.$slots, `edge-${_}`)), 256))
        ]),
        "connection-name": Ge(() => [
          ye(f.$slots, "connection-line")
        ]),
        "zoom-pane": Ge(() => [
          ye(f.$slots, "zoom-pane")
        ]),
        default: Ge(() => [
          ye(f.$slots, "default")
        ]),
        _: 3
      }),
      qe(Cd)
    ], 512));
  }
}), $d = {
  name: "Panel",
  compatConfig: { MODE: 3 }
}, Vd = /* @__PURE__ */ ge({
  ...$d,
  props: {
    position: null
  },
  setup(e) {
    const t = e, { userSelectionActive: n } = de(), o = ee(() => `${t.position}`.split("-"));
    return (i, r) => (ie(), ae("div", {
      class: We(["vue-flow__panel", k(o)]),
      style: Le({ pointerEvents: k(n) ? "none" : "all" })
    }, [
      ye(i.$slots, "default")
    ], 6));
  }
}), Dn = 0.1, Hd = (e) => {
  const t = de({ id: e }), n = S(t, "nodes"), o = S(t, "d3Zoom"), i = S(t, "d3Selection"), r = S(t, "dimensions"), a = S(t, "translateExtent"), s = S(t, "minZoom"), l = S(t, "maxZoom"), u = S(t, "viewport"), c = S(t, "snapToGrid"), h = S(t, "snapGrid"), g = S(t, "getNodes");
  return {
    zoomIn: (d) => {
      w(1.2, d == null ? void 0 : d.duration);
    },
    zoomOut: (d) => {
      w(1 / 1.2, d == null ? void 0 : d.duration);
    },
    zoomTo: (d, _) => {
      i.value && o.value && o.value.scaleTo(An(i.value, _ == null ? void 0 : _.duration), d);
    },
    setTransform: (d, _) => {
      f(d.x, d.y, d.zoom, _ == null ? void 0 : _.duration);
    },
    getTransform: () => ({
      x: u.value.x,
      y: u.value.y,
      zoom: u.value.zoom
    }),
    fitView: (d = {
      padding: Dn,
      includeHiddenNodes: !1,
      duration: 0
    }) => {
      if (!n.value.length)
        return;
      const _ = (d.includeHiddenNodes ? n.value : g.value).filter(($) => {
        var G;
        const I = $.initialized && $.dimensions.width && $.dimensions.height;
        let m = !0;
        return (G = d.nodes) != null && G.length && (m = d.nodes.includes($.id)), I && m;
      }), x = lo(_), { x: N, y: B, zoom: y } = Yt(
        x,
        r.value.width,
        r.value.height,
        d.minZoom ?? s.value,
        d.maxZoom ?? l.value,
        d.padding ?? Dn,
        d.offset
      );
      f(N, B, y, d == null ? void 0 : d.duration);
    },
    setCenter: (d, _, x) => {
      const N = typeof (x == null ? void 0 : x.zoom) < "u" ? x.zoom : l.value, B = r.value.width / 2 - d * N, y = r.value.height / 2 - _ * N;
      f(B, y, N, x == null ? void 0 : x.duration);
    },
    fitBounds: (d, _ = { padding: Dn }) => {
      const { x, y: N, zoom: B } = Yt(d, r.value.width, r.value.height, s.value, l.value, _.padding);
      f(x, N, B, _ == null ? void 0 : _.duration);
    },
    project: (d) => so(d, u.value, c.value, h.value)
  };
  function w(d, _) {
    i.value && o.value && o.value.scaleBy(An(i.value, _), d);
  }
  function f(d, _, x, N) {
    const { x: B, y } = ro({ x: -d, y: -_ }, a.value), $ = ht.translate(-B, -y).scale(x);
    i.value && o.value && o.value.transform(An(i.value, N), $);
  }
};
function An(e, t = 0) {
  return e.transition().duration(t);
}
function Ld(e) {
  const t = e ?? He(Mi, ""), n = He($i, null), { findEdge: o, emits: i } = de(), r = o(t);
  return r || i.error(new ve(he.EDGE_NOT_FOUND, t)), {
    id: t,
    edge: r,
    edgeEl: n
  };
}
export {
  hn as BaseEdge,
  Dl as BezierEdge,
  Ye as ConnectionLineType,
  je as ConnectionMode,
  Ad as EdgeLabelRenderer,
  Pl as EdgeText,
  he as ErrorCode,
  tt as GlobalVueFlowStorage,
  Zt as Handle,
  Fn as MarkerType,
  Ni as NodeIdInjection,
  Xt as PanOnScrollMode,
  Vd as Panel,
  ma as PanelPosition,
  Q as Position,
  uo as SelectionMode,
  Al as SimpleBezierEdge,
  tr as SmoothStepEdge,
  Vl as StepEdge,
  Hl as StraightEdge,
  Rd as VueFlow,
  ve as VueFlowError,
  To as VueFlowInjection,
  Td as addEdge,
  en as applyChanges,
  zd as applyEdgeChanges,
  Bd as applyNodeChanges,
  ct as clamp,
  _i as connectionExists,
  ru as defaultEdgeTypes,
  iu as defaultNodeTypes,
  Ji as getBezierEdgeCenter,
  Zn as getBezierPath,
  Dd as getBoundsofRects,
  rn as getConnectedEdges,
  Id as getIncomers,
  Xe as getMarkerId,
  Ei as getNodesInside,
  Od as getOutgoers,
  lo as getRectOfNodes,
  er as getSimpleBezierPath,
  Qi as getSimpleEdgeCenter,
  Kn as getSmoothStepPath,
  nr as getStraightPath,
  Yt as getTransformForBounds,
  fa as graphPosToZoomedPos,
  $e as isEdge,
  ua as isGraphEdge,
  et as isGraphNode,
  xt as isNode,
  so as pointToRendererPoint,
  fa as rendererPointToPoint,
  Pd as updateEdge,
  Ld as useEdge,
  Aa as useGetPointerPosition,
  Ii as useHandle,
  pa as useNode,
  de as useVueFlow,
  Hd as useZoomPanHelper
};
